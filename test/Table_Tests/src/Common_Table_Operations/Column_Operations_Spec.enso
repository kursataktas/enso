from Standard.Base import all

import Standard.Base.Errors.Common.Arithmetic_Error
import Standard.Base.Errors.Common.Incomparable_Values
import Standard.Base.Errors.Common.Type_Error
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Meta.Type
import Standard.Database.DB_Column.DB_Column
import Standard.Database.Internal.Replace_Params.Replace_Params

from Standard.Table import Bits, Value_Type, Column_Ref, Column
from Standard.Table.Errors import all

from Standard.Database.Errors import all
import Standard.Database.Feature.Feature
import Standard.Database.DB_Table.DB_Table

from Standard.Test import all

import enso_dev.Base_Tests.Data.Round_Spec

import project.Common_Table_Operations.Main.Char_Max_Size_After_Substring_Behavior
from project.Common_Table_Operations.Util import all

main filter=Nothing = run_default_backend add_specs filter

type Arithmetic_Data
    Value ~data

    x self = self.data.at 0
    y self = self.data.at 1
    z self = self.data.at 2

    setup table_builder = Arithmetic_Data.Value <|
        t2 = table_builder [["x", [1, 4, 5, Nothing]], ["y", [2.0, 3.25, 5.0, Nothing]], ["z", [Decimal.new 2, Decimal.new 4.5, Decimal.new 5.0, Nothing]], ["row_id", [1, 2, 3, 4]]] . sort "row_id"
        x = t2.at "x"
        y = t2.at "y"
        z = t2.at "z"
        [x, y, z]

type Min_Max_Data
    Value ~data

    a self = self.data.at 0
    b self = self.data.at 1
    c self = self.data.at 2
    t self = self.data.at 3

    setup table_builder = Min_Max_Data.Value <|
        t = table_builder [["a", [1, 2, 3]], ["b", [4.5, 5.5, 6.5]], ["c", ['a', 'b', 'c']], ["d", [True, False, True]]] . sort "a"
        a = t.at "a"
        b = t.at "b"
        c = t.at "c"
        [a, b, c, t]

type Min_Max_Datetime_Data
    Value ~table

    setup table_builder = Min_Max_Datetime_Data.Value <|
        dates1 = [Date.new 2021 1 1, Date.new 2021 1 2, Date.new 2021 1 3]
        dates2 = [Date.new 2021 1 1, Date.new 2021 1 3, Date.new 2000 12 1]
        times1 = [Time_Of_Day.new 1 2 3 4, Time_Of_Day.new 3 4 5 6, Time_Of_Day.new 5 6 7 8]
        times2 = [Time_Of_Day.new 1 2 3 4, Time_Of_Day.new 1 1 1 1, Time_Of_Day.new 10 10 10 10]
        date_times1 = [Date_Time.new 2021 1 1 1 2 3 4, Date_Time.new 2021 1 2 3 4 5 6, Date_Time.new 2021 1 3 5 6 7 8]
        date_times2 = [Date_Time.new 2021 1 1 1 2 3 4, Date_Time.new 2021 1 3 1 2 3 4, Date_Time.new 2000 12 1 10 10 10 10]
        table_builder [["ix", [1, 2, 3]], ["dates1", dates1], ["dates2", dates2], ["times1", times1], ["times2", times2], ["date_times1", date_times1], ["date_times2", date_times2]] . sort "ix"

type Literal_Data
    Value ~data

    col0 self = self.data.at 0
    col1 self = self.data.at 1

    setup table_builder = Literal_Data.Value <|
        col0 = table_builder [["x", ['hello Hello', 'hello hello', 'HELLO HELLO']], ["row_id", [1, 2, 3]]] . sort "row_id" . at "x"
        col1 = table_builder [["x", ['a[bcd] A[bCd] a[bcd]', 'abac ad Ab aCAd']], ["row_id", [1, 2]]] . sort "row_id" . at "x"
        [col0, col1]

type Replace_Data
    Value ~data

    col self = self.data.at 0
    patterns self = self.data.at 1
    replacements self = self.data.at 2

    setup table_builder = Replace_Data.Value <|
        table = table_builder [["x", ['hello Hello', 'hello hello', 'HELLO HELLO', 'a[bcd] A[bCd] a[bcd]', 'abac ad Ab aCAd']], ["patterns", ['hello', 'hello', 'hello', 'a[bcd]', 'a[bcd]']], ["replacements", ['bye', 'bye', 'bye', 'hey', 'hey']], ["row_id", [1, 2, 3, 4, 5]]] . sort "row_id"
        col = table.at "x"
        patterns = table.at "patterns"
        replacements = table.at "replacements"
        [col, patterns, replacements]


type Text_Replace_Data
    Value ~data

    a self = self.data.at 0
    b self = self.data.at 1
    c self = self.data.at 2
    d self = self.data.at 3

    setup table_builder = Text_Replace_Data.Value <|
        t4 = table_builder [["A", ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]], ["B", ["A","O","a","E","o","O"]], ["C", [1,2,3,4,5,6]], ["D", ['',Nothing,'',Nothing,'','']]] . sort "C"
        a = t4.at "A"
        b = t4.at "B"
        c = t4.at "C"
        d = t4.at "D"
        [a, b, c, d]

type Trim_Data
    Value ~data

    a self = self.data.at 0
    b self = self.data.at 1
    c self = self.data.at 2

    setup table_builder = Trim_Data.Value <|
        table = table_builder [["A", [" A ", ' \t\n\rA\r\n\t ', "xxxAxx"]], ["B", [" ",' \t',"x"]], ["C", [1,2,3]]] . sort "C"
        a = table.at "A"
        b = table.at "B"
        c = table.at "C"
        [a, b, c]

type Names_Data
    Value ~data

    t self = self.data.at 0

    setup table_builder = Names_Data.Value <|
        t = table_builder [["a", [1, 2, 3]], ["b", ['x', 'y', 'z']], ["c", [1.0, 2.0, 3.0]], ["d", [True, False, True]]] . sort "a"
        [t]

type Lazy_Ref
    Value ~get

type Connection_Data
    Value ~data

    connection self = self.data.at 0

    setup create_connection_fn = Connection_Data.Value <|
        connection = create_connection_fn Nothing
        [connection]

    teardown self =
        self.connection.close

add_specs suite_builder setup =
    if setup.is_feature_supported Feature.Column_Operations then (add_column_operation_specs suite_builder setup)

add_column_operation_specs suite_builder setup =
    prefix = setup.prefix
    table_builder = setup.table_builder
    create_connection_fn = setup.create_connection_func
    light_table_builder = setup.light_table_builder
    pending_datetime = if setup.test_selection.date_time.not then "Date/Time operations are not supported by this backend."

    suite_builder.group prefix+"(Column_Operations_Spec) Rounding numeric tests" group_builder->
        round_one n dp=0 use_bankers=False =
            table = light_table_builder [["x", [n]]]
            result = table.at "x" . round dp use_bankers
            result.to_vector.at 0

        round_batch n_vec dp_vec use_bankers =
            name_for ix = "x"+ix.to_text
            n_columns = n_vec.map_with_index ix-> n-> [name_for ix, [n]]
            table = light_table_builder n_columns
            new_columns = dp_vec.map_with_index ix-> dp->
                n_col = table.at (name_for ix)
                n_col.round dp use_bankers . rename (name_for ix)
            # In new table input columns are replaced with results of output
            new_table = new_columns.fold table acc-> col-> acc.set col (set_mode=..Update)
            # We read all operations in a single query
            materialized = new_table.read
            Runtime.assert (materialized.row_count == 1)
            materialized.first_row.to_vector
        Round_Spec.add_specs group_builder (Round_Spec.Batch_Runner.Value round_batch round_one) run_advanced=setup.test_selection.run_advanced_edge_case_tests

        group_builder.specify "Decimal places out of range" <|
            3.1 . round 16 . should_fail_with Illegal_Argument
            3.1 . round -16 . should_fail_with Illegal_Argument

    build_sorted_table table_structure table_builder=setup.table_builder =
        # Workaround for https://github.com/enso-org/enso/issues/10321
        if setup.prefix.contains "Snowflake" . not then table_builder table_structure else
            row_count = table_structure.first.second.length
            new_structure = table_structure+[["row_id", (0.up_to row_count) . to_vector]]
            table_builder new_structure . sort "row_id" . remove_columns ["row_id"]

    ## Runs the provided callback with a few combinations of columns, where some
       of them are made Mixed (but still contain only the original values).
       If the backend does not support mixed columns, the callback is run only
       once.
       Note that this is called exponentially many times with the number of
       columns, so the number of columns given to this function must be limited.
    with_mixed_columns_if_supported table_structure callback =
        if table_structure.length > 3 then
            Panic.throw (Illegal_Argument.Error "with_mixed_columns_if_supported: Too many columns.")
        if table_structure.length == 0 then
            Panic.throw (Illegal_Argument.Error "with_mixed_columns_if_supported: No columns provided.")
        callback_with_clue table =
            clue = table.columns.map (c-> c.name + "->" + c.value_type.to_display_text) . join ", " "{Table: " "} "
            Test.with_clue clue <|
                callback table
        case setup.test_selection.supports_mixed_columns of
            False -> callback_with_clue (build_sorted_table table_structure)
            True ->
                all_combinations (Vector.fill table_structure.length [Nothing, Mixed_Type_Object]) . each combination->
                    amended_table_structure = table_structure.zip combination column_definition-> prefix->
                        name = column_definition.first
                        values = column_definition.second
                        [name, [prefix]+values]
                    mixed_table = build_sorted_table amended_table_structure
                    aligned_table = mixed_table.drop 1
                    callback_with_clue aligned_table

    suite_builder.group prefix+"(Column_Operations_Spec) Boolean Column Operations" group_builder->
        table_builder = light_table_builder
        group_builder.specify "iif" <|
            t = build_sorted_table [["X", [True, False, Nothing, True]]]
            c1 = t.at "X" . iif 22 33
            c1.to_vector . should_equal [22, 33, Nothing, 22]
            setup.expect_integer_type <| c1

            c2 = t.at "X" . iif 22 33.0
            c2.to_vector . should_equal [22, 33, Nothing, 22]
            c2.value_type . should_be_a (Value_Type.Float ...)

            c3 = t.at "X" . iif "A" "B"
            c3.to_vector . should_equal ["A", "B", Nothing, "A"]
            c3.value_type . should_be_a (Value_Type.Char ...)

            c4 = t.at "X" . iif Nothing "B"
            c4.to_vector . should_equal [Nothing, "B", Nothing, Nothing]
            c4.value_type . should_be_a (Value_Type.Char ...)

            c5 = t.at "X" . iif 42 Nothing
            c5.to_vector . should_equal [42, Nothing, Nothing, 42]
            setup.expect_integer_type <| c5

            c6 = t.at "X" . iif Nothing Nothing
            c6.to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]

            t.at "X" . iif 22.0 False . should_fail_with No_Common_Type
            t.at "X" . iif 22 "0" . should_fail_with No_Common_Type

        group_builder.specify "iif on Columns" <|
            with_mixed_columns_if_supported [["X", [True, False, Nothing, False]], ["Y", [1, 2, 3, 4]], ["Z", [1.5, 2.0, 3.5, 4.0]]] t1->
                c1 = t1.at "X" . iif (t1.at "Y") (t1.at "Z")
                c1.to_vector . should_equal [1, 2.0, Nothing, 4.0]
                is_mixed = (t1.at "Y" . value_type == Value_Type.Mixed) || (t1.at "Z" . value_type == Value_Type.Mixed)
                case is_mixed of
                    True  -> c1.value_type . should_equal Value_Type.Mixed
                    False -> c1.value_type.is_floating_point . should_be_true

            with_mixed_columns_if_supported [["X", [True, False]], ["Y", [1, 2]], ["Z", [1.5, 3.0]]] t2->
                c2 = t2.at "X" . iif (t2.at "Y") (t2.at "Z")
                c2.to_vector . should_equal [1, 3]
                is_mixed = (t2.at "Y" . value_type == Value_Type.Mixed) || (t2.at "Z" . value_type == Value_Type.Mixed)
                case is_mixed of
                    True  -> c2.value_type . should_equal Value_Type.Mixed
                    False -> c2.value_type.is_floating_point . should_be_true

            with_mixed_columns_if_supported [["X", [True, False]], ["Y", [10, 20]], ["Z", [False, True]]] t3->
                is_y_mixed = t3.at "Y" . value_type == Value_Type.Mixed
                is_any_mixed = is_y_mixed || (t3.at "Z" . value_type == Value_Type.Mixed)
                c1 = t3.at "X" . iif (t3.at "Y") (t3.at "Z")
                case is_any_mixed of
                    True ->
                        c1.value_type . should_equal Value_Type.Mixed
                        c1.to_vector . should_equal [10, True]
                    False -> c1.should_fail_with No_Common_Type
                c2 = t3.at "X" . iif (t3.at "Y") "<NA>"
                case is_y_mixed of
                    True ->
                        c2.value_type . should_equal Value_Type.Mixed
                        c2.to_vector . should_equal [10, "<NA>"]
                    False -> c2.should_fail_with No_Common_Type

        group_builder.specify "iif should correctly unify text columns of various lengths" pending=(if setup.test_selection.fixed_length_text_columns.not then "Fixed-length Char columns are not supported by this backend.") <|
            t0 = table_builder [["x", [False, True, False]], ["A", ["a", "b", "c"]], ["B", ["xyz", "abc", "def"]]]
            t1 = t0 . cast "A" (Value_Type.Char size=1 variable_length=False) . cast "B" (Value_Type.Char size=3 variable_length=False)

            x = t1.at "x"
            a = t1.at "A"
            b = t1.at "B"
            a.value_type.should_equal (Value_Type.Char size=1 variable_length=False)
            b.value_type.should_equal (Value_Type.Char size=3 variable_length=False)

            c = x.iif a b
            c.to_vector.should_equal ["xyz", "b", "def"]
            Test.with_clue "c.value_type="+c.value_type.to_display_text+": " <|
                c.value_type.variable_length.should_be_true

            d = b.cast (Value_Type.Char size=1 variable_length=False)
            e = x.iif a d
            e.to_vector.should_equal ["x", "b", "d"]
            e.value_type.should_equal (Value_Type.Char size=1 variable_length=False)

            f = b.cast (Value_Type.Char size=1 variable_length=True)
            g = x.iif a f
            g.to_vector.should_equal ["x", "b", "d"]
            Test.with_clue "g.value_type="+g.value_type.to_display_text+": " <|
                g.value_type.variable_length.should_be_true

        group_builder.specify "should allow to compute &&, || and not" <|
            with_mixed_columns_if_supported [["X", [True, False, True]], ["Y", [True, False, False]]] t->
                x = t.at "X"
                y = t.at "Y"
                (x || False).to_vector . should_equal [True, False, True]
                (x || True).to_vector . should_equal [True, True, True]
                (x || y).to_vector . should_equal [True, False, True]
                (x && False).to_vector . should_equal [False, False, False]
                (x && True).to_vector . should_equal [True, False, True]
                (x && y).to_vector . should_equal [True, False, False]
                (x || y.not).to_vector . should_equal [True, True, True]

        group_builder.specify "should handle nulls correctly in not" <|
            t = table_builder [["A", [True, False, Nothing]]]
            a = t.at "A"
            a_not = a.not
            a_not.to_vector . should_equal [False, True, Nothing]

        group_builder.specify "should handle nulls correctly in &&" <|
            t = table_builder [["A", [True, True, True, False, False, False, Nothing, Nothing, Nothing]], ["B", [True, False, Nothing, True, False, Nothing, True, False, Nothing]]]
            a = t.at "A"
            (a && True).to_vector . should_equal [True, True, True, False, False, False, Nothing, Nothing, Nothing]
            (a && False).to_vector . should_equal [False, False, False, False, False, False, False, False, False]
            (a && Nothing).to_vector . should_equal [Nothing, Nothing, Nothing, False, False, False, Nothing, Nothing, Nothing]

            a_not = a.not
            (a_not && True).to_vector . should_equal [False, False, False, True, True, True, Nothing, Nothing, Nothing]
            (a_not && False).to_vector . should_equal [False, False, False, False, False, False, False, False, False]
            (a_not && Nothing).to_vector . should_equal [False, False, False, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing]

            b = t.at "B"
            (a && b).to_vector . should_equal [True, False, Nothing, False, False, False, Nothing, False, Nothing]
            (a_not && b).to_vector . should_equal [False, False, False, True, False, Nothing, Nothing, False, Nothing]

        group_builder.specify "should handle nulls correctly in ||" <|
            t = table_builder [["A", [True, True, True, False, False, False, Nothing, Nothing, Nothing]], ["B", [True, False, Nothing, True, False, Nothing, True, False, Nothing]]]
            a = t.at "A"
            (a || True).to_vector . should_equal [True, True, True, True, True, True, True, True, True]
            (a || False).to_vector . should_equal [True, True, True, False, False, False, Nothing, Nothing, Nothing]
            (a || Nothing).to_vector . should_equal [True, True, True, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing]

            a_not = a.not
            (a_not || True).to_vector . should_equal [True, True, True, True, True, True, True, True, True]
            (a_not || False).to_vector . should_equal [False, False, False, True, True, True, Nothing, Nothing, Nothing]
            (a_not || Nothing).to_vector . should_equal [Nothing, Nothing, Nothing, True, True, True, Nothing, Nothing, Nothing]

            b = t.at "B"
            (a || b).to_vector . should_equal [True, True, True, True, False, Nothing, True, Nothing, Nothing]
            (a_not || b).to_vector . should_equal [True, False, Nothing, True, True, True, True, Nothing, Nothing]

        group_builder.specify "should check types" <|
            t = table_builder [["X", [1, 2, 3]], ["Y", ['a', 'b', 'c']], ["Z", [True, False, Nothing]]]

            ((t.at "X") && (t.at "Z")) . should_fail_with Invalid_Value_Type
            ((t.at "Z") && (t.at "X")) . should_fail_with Invalid_Value_Type
            ((t.at "Y") && True) . should_fail_with Invalid_Value_Type

            ((t.at "X") || (t.at "Z")) . should_fail_with Invalid_Value_Type
            ((t.at "Z") || (t.at "X")) . should_fail_with Invalid_Value_Type
            ((t.at "Y") || True) . should_fail_with Invalid_Value_Type

            ((t.at "X") . not) . should_fail_with Invalid_Value_Type
            ((t.at "Y") . iif 10 20) . should_fail_with Invalid_Value_Type

    suite_builder.group prefix+"(Column_Operations_Spec) Column Operations - Equality & Null Handling" group_builder->
        table_builder = setup.light_table_builder

        group_builder.specify "should provide basic == and != comparisons" pending="TODO figure out proper null handling" <|
            with_mixed_columns_if_supported [["x", [1, 4, 5, Nothing]], ["y", [2.0, 3.25, 5.0, Nothing]]] t2->
                x = t2.at "x"
                y = t2.at "y"
                (x == y).to_vector . should_equal [False, False, True, Nothing]
                (x != y).to_vector . should_equal [True, True, False, Nothing]
                (x == 4).to_vector . should_equal [False, True, False, Nothing]
                (x == Nothing).to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]

        group_builder.specify "should allow to check which values are null" <|
            with_mixed_columns_if_supported [["x", [1, 4, 5, Nothing]]] t->
                x = t.at "x"
                x.is_nothing.to_vector . should_equal [False, False, False, True]
                (x + Nothing).is_nothing.to_vector . should_equal [True, True, True, True]
                x.is_present.to_vector . should_equal [True, True, True, False]
                (x + Nothing).is_present.to_vector . should_equal [False, False, False, False]

        group_builder.specify "Column equality should handle nulls correctly" pending="TODO" <|
            a = [2, 3, Nothing, Nothing]
            b = [2, 4, Nothing, 5]
            r = [True, False, True, False]
            a.zip b (==) . should_equal r

            t = table_builder [["A", a], ["B", b]]
            c = (t.at "A") == (t.at "B")
            c.to_vector . should_equal r
            c.value_type.should_equal Value_Type.Boolean

        group_builder.specify "equals_ignore_case for ASCII strings" <|
            x = ["a", "B", "c", "DEF"]
            y = ["aa", "b", "c", "dEf"]
            r = [False, True, True, True]

            x.zip y (.equals_ignore_case) . should_equal r

            with_mixed_columns_if_supported [["X", x], ["Y", y]] t->
                c = (t.at "X") . equals_ignore_case (t.at "Y")
                c.to_vector . should_equal r
                c.value_type.should_equal Value_Type.Boolean
                (t.at "X") . equals_ignore_case "Def" . to_vector . should_equal [False, False, False, True]

        group_builder.specify "equals_ignore_case should check types" <|
            t = table_builder [["X", [1, 2, 3]], ["Y", ['a', 'b', 'c']]]

            r1 = (t.at "X") . equals_ignore_case (t.at "Y") . to_vector
            r1.should_fail_with Invalid_Value_Type

            r2 = (t.at "Y") . equals_ignore_case (t.at "X") . to_vector
            r2.should_fail_with Invalid_Value_Type

            r3 = (t.at "Y") . equals_ignore_case 42 . to_vector
            r3.should_fail_with Invalid_Value_Type

        group_builder.specify "Text Column equality (including case-insensitive) should handle nulls correctly" pending="TODO" <|
            a = ["Z", "a", "b", Nothing, Nothing]
            b = ["Z", "A", "C", Nothing, "d"]
            r_sensitive   = [True, False, False, True, False]
            r_insensitive = [True, True,  False, True, False]

            a.zip b (==) . should_equal r_sensitive
            a.zip b (x-> y-> if x.is_nothing || y.is_nothing then x == y else x.equals_ignore_case y) . should_equal r_insensitive

            t = table_builder [["A", a], ["B", b]]
            ((t.at "A") == (t.at "B")) . to_vector . should_equal r_sensitive
            ((t.at "A").equals_ignore_case (t.at "B")) . to_vector . should_equal r_insensitive

        group_builder.specify "should report a warning if checking equality on floating point columns" <|
            t = table_builder [["X", [1.0, 2.1, 3.2]], ["Y", [1.0, 2.0, 3.2]]]

            r1 = (t.at "X") == (t.at "Y")
            r1.to_vector . should_equal [True, False, True]
            Problems.expect_warning Floating_Point_Equality r1

            r2 = (t.at "X") != (t.at "Y")
            r2.to_vector . should_equal [False, True, False]
            Problems.expect_warning Floating_Point_Equality r2

    suite_builder.group prefix+"(Column_Operations_Spec) Column.fill_nothing/empty" group_builder->
        table_builder = build_sorted_table table_builder=setup.light_table_builder
        group_builder.specify "should allow to fill_nothing from a value" <|
            col = table_builder [["col", [0, Nothing, 4, 5, Nothing, Nothing]]] . at "col"
            default = 300
            r = col.fill_nothing default
            r.to_vector . should_equal [0, 300, 4, 5, 300, 300]
            r.name . should_equal "col"

        group_builder.specify "should allow to fill_nothing from another column" <|
            t = table_builder [["col", [0, Nothing, 4, 5, Nothing, Nothing]], ["def", [1, 2, 10, 20, Nothing, 30]]]
            r = t.at "col" . fill_nothing (t.at "def")
            r.to_vector . should_equal [0, 2, 4, 5, Nothing, 30]
            r.name . should_equal "col"

        group_builder.specify "should allow to fill_empty from a value" <|
            col = table_builder [["col", ["0", Nothing, "4", "5", Nothing, Nothing]]] . at "col"
            default = "default"
            r = col.fill_empty default
            r.to_vector . should_equal ["0", "default", "4", "5", "default", "default"]
            r.name . should_equal "col"

        group_builder.specify "should allow to fill_empty from another column" <|
            t = table_builder [["col", ["0", Nothing, "4", "5", Nothing, Nothing]], ["def", ["1", "2", "10", "20", Nothing, "30"]]]
            r = t.at "col" . fill_nothing (t.at "def")
            r.to_vector . should_equal ["0", "2", "4", "5", Nothing, "30"]
            r.name . should_equal "col"

    suite_builder.group prefix+"(Column_Operations_Spec) Table.fill_nothing/empty" group_builder->
        table_builder = build_sorted_table table_builder=setup.light_table_builder
        group_builder.specify "should allow to fill_nothing from a value" <|
            t = table_builder [["col0", [0, Nothing, 4, 5, Nothing, Nothing]], ["col1", [Nothing, 200, Nothing, 400, 500, Nothing]]]
            default = 1000
            actual = t.fill_nothing ["col0", "col1"] default
            actual.at "col0" . to_vector . should_equal [0, 1000, 4, 5, 1000, 1000]
            actual.at "col1" . to_vector . should_equal [1000, 200, 1000, 400, 500, 1000]

        group_builder.specify "should allow to fill_nothing from larger string and expands type to fit" <|
            t = table_builder [["col0", ["0", Nothing, "4", "5", Nothing, Nothing]]] . cast "col0" (Value_Type.Char size=1 variable_length=False)
            actual = t.fill_nothing ["col0"] "ABCDE"
            actual.at "col0" . to_vector . should_equal ["0", "ABCDE", "4", "5", "ABCDE", "ABCDE"]
            # Snowflake worksheet returns:
            # SELECT SYSTEM$TYPEOF(COALESCE(CAST("literal_table"."x" AS CHAR(1)), 'N/A')) FROM (VALUES ('1'), (NULL), ('a')) AS "literal_table"("x");
            # VARCHAR(3) - so it is correct
            # TODO - investigate JDBC / our mapping bug
            case setup.test_selection.length_restricted_text_columns of
                True -> actual.at "col0" . value_type . should_equal (Value_Type.Char size=5 variable_length=True)
                False -> actual.at "col0" . value_type . should_equal (Value_Type.Char variable_length=True)

        group_builder.specify "should allow to fill_nothing from an empty string" <|
            t = table_builder [["col0", ["0", Nothing, "4", "5", Nothing, Nothing]], ["col1", [Nothing, "200", Nothing, "400", "500", Nothing]]]
            actual = t.fill_nothing ["col0", "col1"] ""
            actual.at "col0" . to_vector . should_equal ["0", "", "4", "5", "", ""]
            actual.at "col1" . to_vector . should_equal ["", "200", "", "400", "500", ""]

        group_builder.specify "should allow to fill_nothing a fixed width from an empty string" <|
            t = table_builder [["col0", [Nothing, "200", Nothing, "400", "500", Nothing]]] . cast "col0" (Value_Type.Char size=3 variable_length=False)
            actual = t.fill_nothing ["col0"] ""
            actual.at "col0" . to_vector . should_equal ["", "200", "", "400", "500", ""]
            case setup.test_selection.length_restricted_text_columns of
                True -> actual.at "col0" . value_type . should_equal (Value_Type.Char size=3 variable_length=True)
                False -> actual.at "col0" . value_type . should_equal (Value_Type.Char variable_length=True)

        group_builder.specify "should allow to fill_nothing a fixed width of width 1 correctly expanding output types" <|
            t = table_builder [["col0", ["a", Nothing, " "]]] . cast "col0" (Value_Type.Char size=1 variable_length=False)
            fillBlank = t.fill_nothing ["col0"] ""
            fillOneSpace = t.fill_nothing ["col0"] " "
            fillTwoSpaces = t.fill_nothing ["col0"] "  "
            case setup.test_selection.length_restricted_text_columns of
                True ->
                    fillBlank.at "col0" . value_type . should_equal (Value_Type.Char size=1 variable_length=True)
                    case setup.test_selection.fixed_length_text_columns of
                        True  -> fillOneSpace.at "col0" . value_type . should_equal (Value_Type.Char size=1 variable_length=False)
                        False -> fillOneSpace.at "col0" . value_type . should_equal (Value_Type.Char size=1 variable_length=True)
                    fillTwoSpaces.at "col0" . value_type . should_equal (Value_Type.Char size=2 variable_length=True)
                False ->
                    fillBlank.at "col0" . value_type . should_equal (Value_Type.Char variable_length=True)
                    fillOneSpace.at "col0" . value_type . should_equal (Value_Type.Char variable_length=True)
                    fillTwoSpaces.at "col0" . value_type . should_equal (Value_Type.Char variable_length=True)

            case setup.test_selection.removes_trailing_whitespace_casting_from_char_to_varchar of
                True -> fillBlank.at "col0" . to_vector . should_equal ["a", "", ""]
                False -> fillBlank.at "col0" . to_vector . should_equal ["a", "", " "]

            fillOneSpace.at "col0" . to_vector . should_equal ["a", " ", " "]

            case setup.test_selection.removes_trailing_whitespace_casting_from_char_to_varchar of
                True -> fillTwoSpaces.at "col0" . to_vector . should_equal ["a", "", ""]
                False -> fillTwoSpaces.at "col0" . to_vector . should_equal ["a", "  ", " "]

        group_builder.specify "should allow to fill_nothing a fixed width with a string of correct length without changing the type" <|
            t = table_builder [["col0", [Nothing, "200", Nothing, "400", "500", Nothing]]] . cast "col0" (Value_Type.Char size=3 variable_length=False)
            actual = t.fill_nothing ["col0"] "   "
            actual.at "col0" . to_vector . should_equal ["   ", "200", "   ", "400", "500", "   "]

            case setup.test_selection.length_restricted_text_columns of
                True ->
                    case setup.test_selection.fixed_length_text_columns of
                        True  -> actual.at "col0" . value_type . should_equal (Value_Type.Char size=3 variable_length=False)
                        False -> actual.at "col0" . value_type . should_equal (Value_Type.Char size=3 variable_length=True)
                False -> actual.at "col0" . value_type . should_equal (Value_Type.Char variable_length=True)

        group_builder.specify "should allow to fill_nothing from other columns" <|
            t = table_builder [["col0", [0, Nothing, 4, 5, Nothing, Nothing]], ["col1", [Nothing, 200, Nothing, 400, 500, Nothing]], ["def", [1, 2, 10, 20, Nothing, 30]]]
            actual = t.fill_nothing ["col0", "col1"] (t.at "def")
            actual.at "col0" . to_vector . should_equal [0, 2, 4, 5, Nothing, 30]
            actual.at "col1" . to_vector . should_equal [1, 200, 10, 400, 500, 30]

        group_builder.specify "should allow to fill_empty from a value" <|
            t = table_builder [["col0", ["0", Nothing, "4", "5", Nothing, Nothing]], ["col1", [Nothing, "200", Nothing, "400", "500", Nothing]]]
            default = "1000"
            actual = t.fill_empty ["col0", "col1"] default
            actual.at "col0" . to_vector . should_equal ["0", "1000", "4", "5", "1000", "1000"]
            actual.at "col1" . to_vector . should_equal ["1000", "200", "1000", "400", "500", "1000"]

        group_builder.specify "should allow to fill_empty from other columns" <|
            t = table_builder [["col0", ["0", Nothing, "4", "5", Nothing, Nothing]], ["col1", [Nothing, "200", Nothing, "400", "500", Nothing]], ["def", ["1", "2", "10", "20", Nothing, "30"]]]
            actual = t.fill_empty ["col0", "col1"] (t.at "def")
            actual.at "col0" . to_vector . should_equal ["0", "2", "4", "5", Nothing, "30"]
            actual.at "col1" . to_vector . should_equal ["1", "200", "10", "400", "500", "30"]

        group_builder.specify "fill_nothing should leave other columns alone" <|
            t = table_builder [["col0", [0, Nothing, 4, 5, Nothing, Nothing]], ["col_between", [3, 4, 5, 6, 7, 8]], ["col1", [Nothing, 200, Nothing, 400, 500, Nothing]], ["def", [1, 2, 10, 20, Nothing, 30]]]
            default = 1000
            actual = t.fill_nothing ["col0", "col1"] default
            actual.at "col0" . to_vector . should_equal [0, 1000, 4, 5, 1000, 1000]
            actual.at "col_between" . to_vector . should_equal [3, 4, 5, 6, 7, 8]
            actual.at "col1" . to_vector . should_equal [1000, 200, 1000, 400, 500, 1000]
            actual.column_names . should_equal ["col0", "col_between", "col1", "def"]

        group_builder.specify "fill_nothing should allow selection by regex" <|
            t = table_builder [["col0", [0, Nothing, 4, 5, Nothing, Nothing]], ["col_between", [3, 4, 5, 6, 7, 8]], ["col1", [Nothing, 200, Nothing, 400, 500, Nothing]], ["def", [1, 2, 10, 20, Nothing, 30]]]
            default = 1000
            actual = t.fill_nothing [regex ("col.*")] default
            actual.at "col0" . to_vector . should_equal [0, 1000, 4, 5, 1000, 1000]
            actual.at "col_between" . to_vector . should_equal [3, 4, 5, 6, 7, 8]
            actual.at "col1" . to_vector . should_equal [1000, 200, 1000, 400, 500, 1000]
            actual.column_names . should_equal ["col0", "col_between", "col1", "def"]

        group_builder.specify "fill_nothing should allow selection by type" <|
            t = table_builder [["col0", [0, Nothing, 4, 5, Nothing, Nothing]], ["col_between", [3, 4, 5, 6, 7, 8]], ["col1", [Nothing, "200", Nothing, "400", "500", Nothing]], ["def", [1, 2, 10, 20, Nothing, 30]]]
            default = 1000
            actual = t.fill_nothing [..By_Type ..Integer] default
            actual.at "col0" . to_vector . should_equal [0, 1000, 4, 5, 1000, 1000]
            actual.at "col_between" . to_vector . should_equal [3, 4, 5, 6, 7, 8]
            actual.at "col1" . to_vector . should_equal [Nothing, "200", Nothing, "400", "500", Nothing]
            actual.column_names . should_equal ["col0", "col_between", "col1", "def"]

        group_builder.specify "fill_nothing should work with integer column selectors" <|
            t = table_builder [["col0", [0, Nothing, 4, 5, Nothing, Nothing]], ["col_between", [3, 4, 5, 6, 7, 8]], ["col1", [Nothing, 200, Nothing, 400, 500, Nothing]], ["def", [1, 2, 10, 20, Nothing, 30]]]
            default = 1000
            actual = t.fill_nothing [0, 2] default
            actual.at "col0" . to_vector . should_equal [0, 1000, 4, 5, 1000, 1000]
            actual.at "col_between" . to_vector . should_equal [3, 4, 5, 6, 7, 8]
            actual.at "col1" . to_vector . should_equal [1000, 200, 1000, 400, 500, 1000]
            actual.column_names . should_equal ["col0", "col_between", "col1", "def"]

        group_builder.specify "fill_nothing should cope with notted boolean columns" <|
            t = table_builder [["col0", [True, False, Nothing, True]], ["colTrue", [True, True, True, True]], ["colFalse", [False, False, False, False]]]
            s = t.set (t.at "col0" . not) "col1"
            s_false = s.fill_nothing ["col1"] False
            s_false.at "col1" . to_vector . should_equal [False, True, False, False]
            s_false_2 = s.fill_nothing ["col1"] (s.at "colFalse")
            s_false_2.at "col1" . to_vector . should_equal [False, True, False, False]
            s_true = s.fill_nothing ["col1"] True
            s_true.at "col1" . to_vector . should_equal [False, True, True, False]
            s_true_2 = s.fill_nothing ["col1"] (s.at "colTrue")
            s_true_2.at "col1" . to_vector . should_equal [False, True, True, False]

    suite_builder.group prefix+"(Column_Operations_Spec) Table.text_replace" group_builder->
        table_builder = build_sorted_table table_builder=setup.light_table_builder
        group_builder.specify "should allow to replace values in a table" <|
            with_mixed_columns_if_supported [["col0", ["abc", "def", "ghi"]], ["col1", ["nabc", "ndef", "asdf"]]] t->
                actual = t.text_replace ["col0", "col1"] "ab" "xy"
                actual.at "col0" . to_vector . should_equal ["xyc", "def", "ghi"]
                actual.at "col1" . to_vector . should_equal ["nxyc", "ndef", "asdf"]
        
        group_builder.specify "should allow to replace values in a table selecting columns with regex" <|
            with_mixed_columns_if_supported [["col0", ["abc", "def", "ghi"]], ["col1", ["nabc", "ndef", "asdf"]], ["zzz", ["nabc", "ndef", "asdf"]]] t->
                actual = t.text_replace [(regex "col.*")] "ab" "xy"
                actual.at "col0" . to_vector . should_equal ["xyc", "def", "ghi"]
                actual.at "col1" . to_vector . should_equal ["nxyc", "ndef", "asdf"]
                actual.at "zzz" . to_vector . should_equal ["nabc", "ndef", "asdf"]

        group_builder.specify "should allow to replace values in a table selecting columns by type" <|
            t = table_builder [["col0", ["abc", "def", "ghi"]], ["col1", ["nabc", "ndef", "asdf"]], ["zzz", [1, 2, 3]]]
            actual = t.text_replace [..By_Type ..Char] "ab" "xy"
            actual.at "col0" . to_vector . should_equal ["xyc", "def", "ghi"]
            actual.at "col1" . to_vector . should_equal ["nxyc", "ndef", "asdf"]
            actual.at "zzz" . to_vector . should_equal [1, 2, 3]

        group_builder.specify "should allow to replace values in a table with a regex" <|
            t = table_builder [["col0", ["abc", "def", "ghi"]], ["col1", ["nabc", "ndef", "asdf"]]]
            actual = t.text_replace ["col0", "col1"] "[bdi]".to_regex "xy"
            case actual.is_error && setup.is_database of
                True ->
                    actual.should_fail_with Unsupported_Database_Operation
                False ->
                    actual.at "col0" . to_vector . should_equal ["axyc", "xyef", "ghxy"]
                    actual.at "col1" . to_vector . should_equal ["naxyc", "nxyef", "asxyf"]

        group_builder.specify "should allow to replace values in a table with a named_pattern" <|
            t = table_builder [["col0", ["abc123", "123def", "ghi456"]], ["col1", ["nabc123", "123ndef", "asdf456"]]]
            actual = t.text_replace ["col0"] Named_Pattern.Leading_Numbers "xy"
            case actual.is_error && setup.is_database of
                True ->
                    actual.should_fail_with Unsupported_Database_Operation
                False ->
                    actual.at "col0" . to_vector . should_equal ["abc123", "xydef", "ghi456"]
                    actual.at "col1" . to_vector . should_equal ["nabc123", "123ndef", "asdf456"]

        group_builder.specify "should allow to replace values in a table with a column" <|
            t = table_builder [["col0", ["abc", "def", "ghi"]], ["col1", ["nabc", "ndef", "asdf"]], ["col2", ["xy", "yx", "zz"]]]
            actual = t.text_replace ["col0", "col1"] "[bdi]".to_regex (t.at "col2")
            case actual.is_error && setup.is_database of
                True ->
                    actual.should_fail_with Unsupported_Database_Operation
                False ->
                    actual.at "col0" . to_vector . should_equal ["axyc", "yxef", "ghzz"]
                    actual.at "col1" . to_vector . should_equal ["naxyc", "nyxef", "aszzf"]
                    actual.at "col2" . to_vector . should_equal ["xy", "yx", "zz"]

        group_builder.specify "should allow to use Column_Ref in replace" <|
            t = table_builder [["txt", ["abc", "def", "ghi"]], ["term", ["b", "d", "i"]], ["new", ["X", "Y", "Z"]]]
            t1 = t.text_replace "txt" (Column_Ref.Name "term") (Column_Ref.Name "new")
            case t1.is_error && setup.is_database of
                True ->
                    t1.should_fail_with Unsupported_Database_Operation
                False ->
                    t1.at "txt" . to_vector . should_equal ["aXc", "Yef", "ghZ"]

    suite_builder.group prefix+"(Column_Operations_Spec) Column Comparisons" group_builder->
        table_builder = build_sorted_table table_builder=setup.light_table_builder

        group_builder.specify "(Column_Operations_Spec) should infer the correct precise value type for mixed columns" <|
            with_mixed_columns_if_supported [["i", [1, 4, 5, Nothing]], ["f", [2.0, 3.25, 5.0, Nothing]], ["d", [dec "2.0", dec "3.25", dec "5.0", Nothing]]] t->
                setup.is_integer_type (t.at "i").inferred_precise_value_type . should_be_true
                (t.at "f").inferred_precise_value_type . should_be_a (Value_Type.Float ...)

                case setup.test_selection.supports_decimal_type of
                    True ->
                        (t.at "d").inferred_precise_value_type . should_be_a (Value_Type.Decimal ...)
                    False ->
                        (t.at "d").inferred_precise_value_type . should_be_a (Value_Type.Integer ...)

        if setup.test_selection.run_advanced_edge_case_tests then
            group_builder.specify "(Column_Operations_Spec) should allow to compare numbers (including mixed types)" <|
                x_values = [1.25, 4.5, 5.0]
                y_values = [2.0, 3.0, 5.0]

                converters = [.truncate, x->x, dec]
                converters.map x_converter-> converters.map y_converter->
                    x_values_converted = x_values.map x_converter
                    y_values_converted = y_values.map y_converter
                    with_mixed_columns_if_supported [['x', x_values_converted + [Nothing]], ['y', y_values_converted + [Nothing]]] t->
                        x = t.at "x"
                        y = t.at "y"

                        Test.with_clue " comparison: "+x.value_type.to_text+', '+y.value_type.to_text+" " <|
                            (x < y).to_vector . should_equal [True, False, False, Nothing]
                            (x <= y).to_vector . should_equal [True, False, True, Nothing]
                            (x > y).to_vector . should_equal (x <= y).not.to_vector
                            (x >= y).to_vector . should_equal (x < y).not.to_vector

                            converters.map converter->
                                const_float = 3.0
                                constant = converter const_float
                                Test.with_clue " constant: "+(Meta.get_simple_type_name constant) <|
                                    (x == constant).to_vector . should_equal [False, False, False, Nothing]
                                    (x != constant).to_vector . should_equal [True, True, True, Nothing]
                                    (y == constant).to_vector . should_equal [False, True, False, Nothing]
                                    (y != constant).to_vector . should_equal [True, False, True, Nothing]

                            [6.5, 1000.5].map const_float->
                                converters.map converter->
                                    constant = converter const_float
                                    Test.with_clue " constant: "+(Meta.get_simple_type_name constant) <|
                                        (x < -constant).to_vector . should_equal [False, False, False, Nothing]
                                        (x < constant).to_vector . should_equal [True, True, True, Nothing]
                                        (x <= -constant).to_vector . should_equal [False, False, False, Nothing]
                                        (x <= constant).to_vector . should_equal [True, True, True, Nothing]

                                        (y > -constant).to_vector . should_equal [True, True, True, Nothing]
                                        (y > constant).to_vector . should_equal [False, False, False, Nothing]
                                        (y >= -constant).to_vector . should_equal [True, True, True, Nothing]
                                        (y >= constant).to_vector . should_equal [False, False, False, Nothing]

                            [(<), (<=), (>), (>=)].each op->
                                op x y . value_type . should_equal Value_Type.Boolean
                                op x y . to_vector . should_succeed
                                op x 23 . to_vector . should_succeed
                                op y 23 . to_vector . should_succeed
                                op x 1.5 . to_vector . should_succeed
                                op x (dec 1.5) . to_vector . should_succeed

        group_builder.specify "should allow to compare texts" <|
            t0 = table_builder [["X", ["a", "b", "c"]], ["Y", ["a", "b", "d"]]]
            t = t0.cast "X" (Value_Type.Char size=1 variable_length=False)

            [(<), (<=), (>), (>=)].each op->
                op (t.at "X") (t.at "Y") . value_type . should_equal Value_Type.Boolean
                op (t.at "X") (t.at "Y") . to_vector . should_succeed
                op (t.at "X") "abc" . to_vector . should_succeed

        group_builder.specify "should allow to compare booleans" <|
            t = table_builder [["X", [True, False, True]], ["Y", [False, True, True]]]

            ((t.at "X") < (t.at "Y")).to_vector . should_equal [False, True, False]
            ((t.at "X") >= (t.at "Y")).to_vector . should_equal [True, False, True]
            ((t.at "X") <= (t.at "Y")).to_vector . should_equal [False, True, True]
            ((t.at "X") > (t.at "Y")).to_vector . should_equal [True, False, False]

            ((t.at "X") < True).to_vector . should_equal [False, True, False]
            ((t.at "X") >= True).to_vector . should_equal [True, False, True]
            ((t.at "X") <= True).to_vector . should_equal [True, True, True]
            ((t.at "X") > True).to_vector . should_equal [False, False, False]

        group_builder.specify "should report error if incomparable types are compared" <|
            t = table_builder [["X", [1, 2]], ["Y", ["a", "b"]], ["Z", [True, False]]]
            r42 = (t.at "X") < (t.at "Y")
            r42.should_fail_with Invalid_Value_Type

            [(<), (<=), (>), (>=)].each op->
                r1 = op (t.at "X") (t.at "Y")
                r1.should_fail_with Invalid_Value_Type
                r1.catch . should_be_a Invalid_Value_Type.Incomparable

                op (t.at "X") "FOO" . should_fail_with Invalid_Value_Type
                op (t.at "Y") 42 . should_fail_with Invalid_Value_Type
                op (t.at "Y") False . should_fail_with Invalid_Value_Type
                op (t.at "Z") 32 . should_fail_with Invalid_Value_Type
                op (t.at "Z") (t.at "X") . should_fail_with Invalid_Value_Type

        if setup.test_selection.supports_mixed_columns then
            group_builder.specify "should allow comparing Mixed columns" <|
                t1 = table_builder [["X", ["a", 23]], ["Y", ["b", 1]]]
                ((t1.at "X") == (t1.at "Y")) . to_vector . should_equal [False, False]
                ((t1.at "X") <= (t1.at "Y")) . to_vector . should_equal [True, False]
                ((t1.at "X") > (t1.at "Y")) . to_vector . should_equal [False, True]

                t1_2 = table_builder [["X", [1, "2"]], ["Y", ["b", 1]]]
                ((t1_2.at "X") == (t1_2.at "Y")) . to_vector . should_equal [False, False]
                ((t1_2.at "X") <= (t1_2.at "Y")) . to_vector . should_fail_with Incomparable_Values

                t2 = table_builder [["X", [1, 2]], ["Y", ["b", 1]]]
                ((t2.at "X") == (t2.at "Y")) . to_vector . should_equal [False, False]
                ((t2.at "X") <= (t2.at "Y")) . to_vector . should_fail_with Incomparable_Values
                ((t2.at "Y") > (t2.at "X")) . to_vector . should_fail_with Incomparable_Values

                t3 = table_builder [["X", [1.0, 2.0]], ["Y", ["b", 1]]]
                ((t3.at "X") == (t3.at "Y")) . to_vector . should_equal [False, False]
                ((t3.at "X") <= (t3.at "Y")) . to_vector . should_fail_with Incomparable_Values
                ((t3.at "Y") > (t3.at "X")) . to_vector . should_fail_with Incomparable_Values

                t4 = table_builder [["X", ["a", "b"]], ["Y", ["b", 1]]]
                ((t4.at "X") == (t4.at "Y")) . to_vector . should_equal [False, False]
                ((t4.at "X") <= (t4.at "Y")) . to_vector . should_fail_with Incomparable_Values
                ((t4.at "Y") > (t4.at "X")) . to_vector . should_fail_with Incomparable_Values

                t5 = table_builder [["X", [Date.new 2022, Date.new 2019]], ["Y", ["b", 1]]]
                ((t5.at "X") == (t5.at "Y")) . to_vector . should_equal [False, False]
                ((t5.at "X") <= (t5.at "Y")) . to_vector . should_fail_with Incomparable_Values
                ((t5.at "Y") > (t5.at "X")) . to_vector . should_fail_with Incomparable_Values

                t6 = table_builder [["X", [Time_Of_Day.new 21, Time_Of_Day.new 22]], ["Y", ["b", 1]]]
                ((t6.at "X") == (t6.at "Y")) . to_vector . should_equal [False, False]
                ((t6.at "X") <= (t6.at "Y")) . to_vector . should_fail_with Incomparable_Values
                ((t6.at "Y") > (t6.at "X")) . to_vector . should_fail_with Incomparable_Values

                t7 = table_builder [["X", [Date_Time.new 2022, Date_Time.new 2019]], ["Y", ["b", 1]]]
                ((t7.at "X") == (t7.at "Y")) . to_vector . should_equal [False, False]
                ((t7.at "X") <= (t7.at "Y")) . to_vector . should_fail_with Incomparable_Values
                ((t7.at "Y") > (t7.at "X")) . to_vector . should_fail_with Incomparable_Values

        group_builder.specify "Between should return null if any of the values are null" pending="TODO" <|
            a = [2, 3, Nothing, 7,       5,       Nothing]
            b = [0, 5, 7,       Nothing, 7,       Nothing]
            c = [9, 8, 7,       7,       Nothing, Nothing]
            r = [True, False, Nothing, Nothing, Nothing, Nothing]

            t = table_builder [["A", a], ["B", b], ["C", c]]
            ((t.at "A").between (t.at "B") (t.at "C")) . to_vector . should_equal r

    suite_builder.group prefix+"(Column_Operations_Spec) Arithmetic Column Operations" group_builder->
        data = Arithmetic_Data.setup setup.table_builder
        group_builder.specify "should allow basic operations" <|
            (data.x + data.y).to_vector . should_equal [3, 7.25, 10, Nothing]
            (data.x - data.y).to_vector . should_equal [-1.0, 0.75, 0.0, Nothing]
            (data.x * data.y).to_vector . should_equal [2.0, 13.0, 25.0, Nothing]
            (data.y + data.z).to_vector . should_equal [4.0, 7.75, 10, Nothing]
            (data.y - data.z).to_vector . should_equal [0.0, -1.25, 0.0, Nothing]
            (data.y * data.z).to_vector . should_equal [4.0, 14.625, 25.0, Nothing]

        group_builder.specify "should allow combining a column with a scalar" <|
            (data.x + 100).to_vector . should_equal [101, 104, 105, Nothing]
            (data.x * 10).to_vector . should_equal [10, 40, 50, Nothing]
            (data.x - 10).to_vector . should_equal [-9, -6, -5, Nothing]

        group_builder.specify "should work with mixed types" <|
            with_mixed_columns_if_supported [["X", [100, 25]], ["Y", [2, 5]]] t->
                x = t.at "X"
                y = t.at "Y"
                (x + y).to_vector . should_equal [102, 30]
                (x - y).to_vector . should_equal [98, 20]
                (x * y).to_vector . should_equal [200, 125]
                (x / y).to_vector . should_equal [50, 5]
                (x % y).to_vector . should_equal [0, 0]
                (x ^ y).to_vector . should_equal [10000, 9765625]

        group_builder.specify "should correctly infer the types" <|
            setup.expect_integer_type <| (data.x + data.x)
            (data.x + data.y).value_type . should_be_a (Value_Type.Float ...)
            setup.expect_integer_type <| (data.x + 2)
            is_float_or_decimal (data.x + 1.5)

            setup.expect_integer_type <| (data.x - data.x)
            (data.x - data.y).value_type . should_be_a (Value_Type.Float ...)
            setup.expect_integer_type <| (data.x - 2)
            is_float_or_decimal (data.x - 1.5)

            setup.expect_integer_type <| (data.x * data.x)
            (data.x * data.y).value_type . should_be_a (Value_Type.Float ...)
            setup.expect_integer_type <| (data.x * 2)
            is_float_or_decimal <| (data.x * 1.5)

            (data.x ^ data.x).value_type . is_numeric . should_be_true

        if setup.test_selection.supports_decimal_type then
            # TODO in-memory specific tests may be added in In_Memory/Table_Spec as part of #10429
            divide_in_memory_pending = if setup.is_database.not then "TODO: https://github.com/enso-org/enso/issues/10429"
            group_builder.specify "should correctly infer the types (for decimal division)" pending=divide_in_memory_pending <|
                is_float_or_decimal (data.x / data.x)
                is_float_or_decimal (data.x / data.y)
                is_float_or_decimal (data.x / data.z)
                is_float_or_decimal (data.y / data.z)
                is_float_or_decimal (data.x / 2)
                is_float_or_decimal (data.x / 1.5)

        group_builder.specify "should check types" <|
            t = table_builder [["X", [1, 2]], ["Y", ["a", "b"]], ["Z", [True, False]]]
            x = t.at "X"
            y = t.at "Y"
            z = t.at "Z"

            (x + z) . should_fail_with Illegal_Argument
            (x + False) . should_fail_with Illegal_Argument

            # Mixing text and integers should not be allowed
            (x + y) . should_fail_with Illegal_Argument
            (x + "foo") . should_fail_with Illegal_Argument

            (x - z).should_fail_with Invalid_Value_Type
            (x - "a").should_fail_with Invalid_Value_Type
            (y - "a").should_fail_with Invalid_Value_Type
            (y - 42).should_fail_with Invalid_Value_Type

            (x * z).should_fail_with Invalid_Value_Type
            (x * "a").should_fail_with Invalid_Value_Type
            (y * "a").should_fail_with Invalid_Value_Type
            (y * 42).should_fail_with Invalid_Value_Type

            (x / z).should_fail_with Invalid_Value_Type
            (x / "a").should_fail_with Invalid_Value_Type
            (y / "a").should_fail_with Invalid_Value_Type
            (y / 42).should_fail_with Invalid_Value_Type

            (x ^ z).should_fail_with Invalid_Value_Type
            (x ^ "a").should_fail_with Invalid_Value_Type
            (y ^ "a").should_fail_with Invalid_Value_Type
            (y ^ 42).should_fail_with Invalid_Value_Type

        case setup.flagged ..Supports_Separate_NaN of
            True ->
                table = Lazy_Ref.Value <|
                    build_sorted_table [["X", [1.5, 3.0, Number.positive_infinity, Number.negative_infinity, Number.nan, Nothing]], ["Y", [1, 2, 3, 4, 5, Nothing]], ["Z", ["1", "2", "3", "4", "5", Nothing]]]

                group_builder.specify "should support is_nan" <|
                    t = table.get
                    t.at "X" . is_nan . to_vector . should_equal [False, False, False, False, True, Nothing]
                    t.at "Y" . is_nan . to_vector . should_equal [False, False, False, False, False, Nothing]
                    t.at "Z" . is_nan . to_vector . should_fail_with Invalid_Value_Type

                group_builder.specify "should support is_infinite" <|
                    t = table.get
                    t.at "X" . is_infinite . to_vector . should_equal [False, False, True, True, False, Nothing]
                    t.at "Y" . is_infinite . to_vector . should_equal [False, False, False, False, False, Nothing]
                    t.at "Z" . is_infinite . to_vector . should_fail_with Invalid_Value_Type

                group_builder.specify "should support is_finite" <|
                    t = table.get
                    t.at "X" . is_finite . to_vector . should_equal [True, True, False, False, False, Nothing]
                    t.at "Y" . is_finite . to_vector . should_equal [True, True, True, True, True, Nothing]
                    t.at "Z" . is_finite . to_vector . should_fail_with Invalid_Value_Type

            False ->
                group_builder.specify "should report that is_nan is not supported" <|
                    t = table_builder [["X", [1.5]]]
                    t.at "X" . is_nan . should_fail_with Unsupported_Database_Operation

                group_builder.specify "should support is_infinite" <|
                    t = build_sorted_table [["X", [1.5, 3.0, Number.positive_infinity, Number.negative_infinity, Nothing]], ["Y", [1, 2, 3, 4, Nothing]], ["Z", ["1", "2", "3", "4", Nothing]]]
                    t.at "X" . is_infinite . to_vector . should_equal [False, False, True, True, Nothing]
                    t.at "Y" . is_infinite . to_vector . should_equal [False, False, False, False, Nothing]
                    t.at "Z" . is_infinite . to_vector . should_fail_with Invalid_Value_Type

                group_builder.specify "should support is_finite" <|
                    t = build_sorted_table [["X", [1.5, 3.0, Number.positive_infinity, Number.negative_infinity, Nothing]], ["Y", [1, 2, 3, 4, Nothing]], ["Z", ["1", "2", "3", "4", Nothing]]]
                    t.at "X" . is_finite . to_vector . should_equal [True, True, False, False, Nothing]
                    t.at "Y" . is_finite . to_vector . should_equal [True, True, True, True, Nothing]
                    t.at "Z" . is_finite . to_vector . should_fail_with Invalid_Value_Type

        group_builder.specify "should support is_blank" <|
            t = build_sorted_table [["X", [1.5, 2, Number.nan, Nothing]], ["Y", [1, Nothing, 3, 4]]]
            t.at "X" . is_blank treat_nans_as_blank=True . to_vector . should_equal [False, False, True, True]
            t.at "Y" . is_blank treat_nans_as_blank=True . to_vector . should_equal [False, True, False, False]

        group_builder.specify "division should be aligned with the Enso arithmetic" <|
            a = [1, 5, 10, 100]
            b = [2, 2, 4, 5]
            r = [0.5, 2.5, 2.5, 20.0]
            a.zip b (/) . should_equal r

            t = build_sorted_table [["A", a], ["B", b]]
            setup.expect_integer_type <| t.at "A"
            setup.expect_integer_type <| t.at "B"

            r2 = (t.at "A") / (t.at "B")
            r2 . to_vector . should_equal r
            is_float_or_decimal r2

            r3 = (t.at "A") / 2
            r3 . to_vector . should_equal [0.5, 2.5, 5.0, 50.0]
            is_float_or_decimal r3

            a2 = [1.2, 5, 10.2, 100]
            b2 = [1.2, 2, 2, 5]
            r4 = [1.0, 2.5, 5.1, 20.0]
            a2.zip b2 (/) . should_equal r4

            t2 = build_sorted_table [["A", a2], ["B", b2]]
            t2.at "A" . value_type . is_floating_point . should_be_true
            t2.at "B" . value_type . is_floating_point . should_be_true

            r5 = (t2.at "A") / (t2.at "B")
            r5 . to_vector . should_equal r4
            is_float_or_decimal r5

            r6 = (t2.at "A") / 2
            r6 . to_vector . should_equal [0.6, 2.5, 5.1, 50.0]
            is_float_or_decimal r6

        db_pending = if setup.is_database then "Arithmetic error handling is currently not implemented for the Database backend."
        group_builder.specify "should allow division by 0 and report warnings" pending=db_pending <|
            t = build_sorted_table [["a", [3, 1, 0]], ["b", [2, 0, 0]], ["c", [1.5, 1.5, 0.0]], ["d", [1.5, 0.0, 0.0]]]
            a = t.at "a"
            b = t.at "b"
            c = t.at "c"
            d = t.at "d"

            has_div_warnings location expected_rows result =
                Test.with_clue location <|
                    warnings = Problems.get_attached_warnings result
                    msg = "Division by zero (at rows " + expected_rows.to_text + ")."
                    warnings.first . should_equal (Arithmetic_Error.Error msg)

            r1 = a / b
            r1.to_vector.to_text . should_equal "[1.5, Infinity, NaN]"
            has_div_warnings "[a] / [b]" [1, 2] r1
            r2 = c / d
            r2.to_vector.to_text . should_equal "[1.0, Infinity, NaN]"
            has_div_warnings "[c] / [d]" [1, 2] r2
            r3 = a / d
            r3.to_vector.to_text . should_equal "[2.0, Infinity, NaN]"
            has_div_warnings "[a] / [d]" [1, 2] r3
            r4 = a / 0
            r4.to_vector.to_text . should_equal "[Infinity, Infinity, NaN]"
            has_div_warnings "[a] / 0" [0, 1, 2] r4
            r5 = c / 0
            r5.to_vector.to_text . should_equal "[Infinity, Infinity, NaN]"
            has_div_warnings "[c] / 0" [0, 1, 2] r5

            r6 = a % b
            r6.to_vector.to_text . should_equal "[1, Nothing, Nothing]"
            has_div_warnings "[a] % [b]" [1, 2] r6
            r7 = c % d
            r7.to_vector.to_text . should_equal "[0.0, NaN, NaN]"
            has_div_warnings "[c] % [d]" [1, 2] r7
            r8 = a % d
            r8.to_vector.to_text . should_equal "[0.0, NaN, NaN]"
            has_div_warnings "[a] % [d]" [1, 2] r8
            r9 = a % 0
            r9.to_vector.to_text . should_equal "[Nothing, Nothing, Nothing]"
            has_div_warnings "[a] % 0" [0, 1, 2] r9
            r10 = c % 0
            r10.to_vector.to_text . should_equal "[NaN, NaN, NaN]"
            has_div_warnings "[c] % 0" [0, 1, 2] r10

        group_builder.specify "should limit the number of rows listed in the message" pending=db_pending <|
            t1 = table_builder [["a", 0.up_to 200 . to_vector]]
            zero = t1.at "a" - t1.at "a"
            div = t1.at "a" / zero
            warnings = Problems.get_attached_warnings div
            warnings.not_empty.should_be_true
            warning = warnings.first
            warning.should_be_a Arithmetic_Error
            warning.message . should_equal "Division by zero (at rows [0, 1, 2, 3, 4, 5, 6, 7, 8, ...])."

        group_builder.specify "should return null if one of arguments is missing" <|
            nulls = [Nothing, Nothing, Nothing, Nothing]
            (data.x + Nothing).to_vector . should_equal nulls
            (data.x - Nothing).to_vector . should_equal nulls
            (data.x * Nothing).to_vector . should_equal nulls
            (data.x / Nothing).to_vector . should_equal nulls

    suite_builder.group prefix+"(Column_Operations_Spec) Rounding-like operations" group_builder->
        table_builder = build_sorted_table table_builder=setup.light_table_builder
        group_builder.specify "should name a rounding column correctly" <|
            table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
            table.at "x" . round . name . should_equal "round([x])"

        test_floatlike typ =
            group_builder.specify "should allow round on a "+typ.to_text+" column" <|
                table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
                result = table.at "x" . cast typ . round
                result.to_vector.should_equal [0, 1, 3, 4, 0, -1, -3, -4]
                result.name . should_equal "round([x])"

            group_builder.specify "should allow round on a "+typ.to_text+" column (to >0 decimal places)" <|
                table = table_builder [["x", [0.51, 0.59, 3.51, 3.59, -0.51, -0.59, -3.51, -3.59]]]
                result = table.at "x" . cast typ . round 1
                result.to_vector.should_equal [0.5, 0.6, 3.5, 3.6, -0.5, -0.6, -3.5, -3.6]
                result.name . should_equal "round([x])"

            group_builder.specify "should allow round on a "+typ.to_text+" column (to <0 decimal places)" <|
                table = table_builder [["x", [51.2, 59.3, 351.45, 359.11, -51.2, -59.3, -351.23, -359.69]]]
                result = table.at "x" . cast typ . round -1
                result.to_vector.should_equal [50.0, 60.0, 350.0, 360.0, -50.0, -60.0, -350.0, -360.0]
                result.name . should_equal "round([x])"

            group_builder.specify "should allow truncate on a "+typ.to_text+" column" <|
                table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
                result = table.at "x" . cast typ . truncate
                result.to_vector.should_equal [0, 0, 3, 3, 0, 0, -3, -3]
                result.name . should_equal "truncate([x])"

            group_builder.specify "should allow ceil on a "+typ.to_text+" column" <|
                table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
                result = table.at "x" . cast typ . ceil
                result.to_vector.should_equal [1, 1, 4, 4, 0, 0, -3, -3]
                result.name . should_equal "ceil([x])"

            group_builder.specify "should allow floor on a "+typ.to_text+" column" <|
                table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
                result = table.at "x" . cast typ . floor
                result.to_vector.should_equal [0, 0, 3, 3, -1, -1, -4, -4]
                result.name . should_equal "floor([x])"

            group_builder.specify "should handle Nothing in rounding on a "+typ.to_text+" column" <|
                table = table_builder [["x", [0.1, 0.9, 3.1, Nothing, Nothing, -0.9, -3.1, -3.9]]]
                result = table.at "x" . cast typ . round
                result.to_vector.should_equal [0, 1, 3, Nothing, Nothing, -1, -3, -4]
                result.name . should_equal "round([x])"

        test_floatlike Value_Type.Float
        if setup.test_selection.supports_decimal_type then
            test_floatlike Value_Type.Decimal

        group_builder.specify "should allow round on an int column" <|
            table = table_builder [["x", [1, 9, 31, 39, -1, -9, -31, -39]]]
            result = table.at "x" . round -1
            result.to_vector.should_equal [0, 10, 30, 40, 0, -10, -30, -40]
            result.name . should_equal "round([x])"

        group_builder.specify "should allow truncate on an int column" <|
            table = table_builder [["x", [0, 3, -3, 1, -2]]]
            result = table.at "x" . truncate
            result.to_vector.should_equal [0, 3, -3, 1, -2]
            result.name . should_equal "truncate([x])"

        group_builder.specify "should allow ceil on an int column" <|
            table = table_builder [["x", [0, 3, -3, 1, -2]]]
            result = table.at "x" . ceil
            result.to_vector.should_equal [0, 3, -3, 1, -2]
            result.name . should_equal "ceil([x])"

        group_builder.specify "should allow floor on an int column" <|
            table = table_builder [["x", [0, 3, -3, 1, -2]]]
            result = table.at "x" . floor
            result.to_vector.should_equal [0, 3, -3, 1, -2]
            result.name . should_equal "floor([x])"

        group_builder.specify "should fail on decimal_places out of range" <|
            table = table_builder [["x", [0, 3, -3, 1, -2]]]
            table.at "x" . round 16 . should_fail_with Illegal_Argument

        if setup.test_selection.supports_decimal_type then
            group_builder.specify "ceil, floor and truncate should work correctly on Integers outside the java Long range" <|
                positive_values = [9223372036854775806, 9223372036854775807, 9223372036854775808, 9223372036854775809, 9223372036854775807000000]
                values = positive_values + positive_values.map .negate
                values.map x->
                    c = table_builder [["x", [x, -x]]] . at "x"
                    c.ceil . to_vector . should_equal [x, -x]
                    c.floor . to_vector . should_equal [x, -x]
                    c.truncate . to_vector . should_equal [x, -x]

        if setup.is_database.not then
            group_builder.specify "ceil, floor and truncate should work correctly on Floats outside the java Long range" <|
                positive_values = [9223372036854775000.0, 9223372036854776000.0, 9223372036854775807000000.0]
                values = positive_values + positive_values.map .negate
                values.map x->
                    x_int = x.truncate
                    c = table_builder [["x", [x, -x]]] . at "x"
                    c.ceil . to_vector . should_equal [x_int, -x_int]
                    c.floor . to_vector . should_equal [x_int, -x_int]
                    c.truncate . to_vector . should_equal [x_int, -x_int]

        if setup.test_selection.supports_decimal_type then
            group_builder.specify "ceil, floor and truncate should work correctly on Decimals" <|
                c = table_builder [["X", [Decimal.new "123492233720368547758075678.25", Decimal.new "179243023788662739454197523.625", Decimal.new "-123492233720368547758075678.25", Decimal.new "-179243023788662739454197523.625"]]] . at "X"
                c.value_type.is_decimal . should_be_true

                c.floor.to_vector.should_equal [Decimal.new "123492233720368547758075678.0", Decimal.new "179243023788662739454197523.0", Decimal.new "-123492233720368547758075679.0", Decimal.new "-179243023788662739454197524.0"]
                c.ceil.to_vector.should_equal [Decimal.new "123492233720368547758075679.0", Decimal.new "179243023788662739454197524.0", Decimal.new "-123492233720368547758075678.0", Decimal.new "-179243023788662739454197523.0"]
                c.truncate.to_vector.should_equal [Decimal.new "123492233720368547758075678.0", Decimal.new "179243023788662739454197523.0", Decimal.new "-123492233720368547758075678.0", Decimal.new "-179243023788662739454197523.0"]

            group_builder.specify "round should work correctly on Decimals" <|
                c = table_builder [["X", [Decimal.new "1.3", Decimal.new "1.5", Decimal.new "1.7", Decimal.new "-1.3", Decimal.new "-1.5", Decimal.new "-1.7"]]] . at "X"
                c.value_type.is_decimal . should_be_true
                c.round 0 . to_vector . should_equal [Decimal.new "1.0", Decimal.new "2.0", Decimal.new "2.0", Decimal.new "-1.0", Decimal.new "-2.0", Decimal.new "-2.0"]

                c2 = table_builder [["X", [Decimal.new "130", Decimal.new "150", Decimal.new "170", Decimal.new "-130", Decimal.new "-150", Decimal.new "-170"]]] . at "X"
                c2.value_type.is_decimal . should_be_true
                c2.round -2 . to_vector . should_equal [Decimal.new "100", Decimal.new "200", Decimal.new "200", Decimal.new "-100", Decimal.new "-200", Decimal.new "-200"]

        group_builder.specify "should allow Nothing/NULL" <|
            table = table_builder [["x", [Nothing, 0.51, 0.59, 3.51, Nothing, 3.59, -0.51, -0.59, -3.51, -3.59]]]
            result = table.at "x" . round 1
            result.to_vector.should_equal [Nothing, 0.5, 0.6, 3.5, Nothing, 3.6, -0.5, -0.6, -3.5, -3.6]

        group_builder.specify "should fail on bad column type" <|
            table = table_builder [["x", ["a", "b"]]]
            table.at "x" . round . should_fail_with Invalid_Value_Type

        group_builder.specify "should work with mixed type columns" <|
            with_mixed_columns_if_supported [["X", [112, 210, 222]]] t->
                x = t.at "X"
                x.floor . to_vector . should_equal [112, 210, 222]
                x.ceil . to_vector . should_equal [112, 210, 222]
                x.round . to_vector . should_equal [112, 210, 222]
                x.truncate . to_vector . should_equal [112, 210, 222]
                x.round (-1) . to_vector . should_equal [110, 210, 220]

            with_mixed_columns_if_supported [["X", [1.0, -2.4, 3.8]]] t->
                x = t.at "X"
                x.floor . to_vector . should_equal [1, -3, 3]
                x.ceil . to_vector . should_equal [1, -2, 4]
                x.round . to_vector . should_equal [1, -2, 4]
                x.truncate . to_vector . should_equal [1, -2, 3]

    suite_builder.group prefix+"(Column_Operations_Spec) Date truncation" pending=pending_datetime group_builder->
        table_builder = build_sorted_table table_builder=setup.light_table_builder
        group_builder.specify "should be able to truncate a column of Date_Times" <|
            dates = [Date_Time.new 2020 10 24 1 2 3, Date_Time.new 2020 10 24 1 2 3]
            table = table_builder [["foo", dates]]
            table.at "foo" . value_type . should_equal (Value_Type.Date_Time with_timezone=True)
            truncated = table.at "foo" . truncate
            truncated . to_vector . should_equal [Date.new 2020 10 24, Date.new 2020 10 24]
            truncated . value_type . should_equal Value_Type.Date
            truncated.name . should_equal "truncate([foo])"

    suite_builder.group prefix+"(Column_Operations_Spec) Text Column Operations" group_builder->
        table_builder = build_sorted_table table_builder=setup.light_table_builder
        group_builder.specify "should handle operations like starts_with, ends_with, contains" <|
            with_mixed_columns_if_supported [["s1", ["foobar", "bar", "baz", "BAB", Nothing]], ["s2", ["foo", "ar", "a", "b", Nothing]]] t3->
                s1 = t3.at "s1"
                s2 = t3.at "s2"
                s1.starts_with s2 . to_vector . should_equal [True, False, False, False, Nothing]
                s1.starts_with s2 Case_Sensitivity.Insensitive . to_vector . should_equal [True, False, False, True, Nothing]
                s1.starts_with "foo" . to_vector . should_equal [True, False, False, False, Nothing]
                s1.starts_with "ba" . to_vector . should_equal [False, True, True, False, Nothing]
                s1.starts_with "ba" Case_Sensitivity.Insensitive . to_vector . should_equal [False, True, True, True, Nothing]

                s1.contains s2 . to_vector . should_equal [True, True, True, False, Nothing]
                s1.contains s2 Case_Sensitivity.Insensitive . to_vector . should_equal [True, True, True, True, Nothing]
                s1.contains "a" . to_vector . should_equal [True, True, True, False, Nothing]
                s1.contains "oo" . to_vector . should_equal [True, False, False, False, Nothing]
                s1.contains "a" Case_Sensitivity.Insensitive . to_vector . should_equal [True, True, True, True, Nothing]

                s1.ends_with s2 . to_vector . should_equal [False, True, False, False, Nothing]
                s1.ends_with s2 Case_Sensitivity.Insensitive . to_vector . should_equal [False, True, False, True, Nothing]
                s1.ends_with "ar" . to_vector . should_equal [True, True, False, False, Nothing]
                s1.ends_with "a" . to_vector . should_equal [False, False, False, False, Nothing]
                s1.ends_with "b" Case_Sensitivity.Insensitive . to_vector . should_equal [False, False, False, True, Nothing]

                s1.like s2 . to_vector . should_equal [False, False, False, False, Nothing]
                s1.like (s2+"%r") . to_vector . should_equal [True, False, False, False, Nothing]
                s1.like "%r%" . to_vector . should_equal [True, True, False, False, Nothing]

        group_builder.specify "should handle operation text_length" <|
            with_mixed_columns_if_supported [["strings", ["foobar", "", Nothing, "👩‍🔬", "café", "It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of light, it was the season of darkness, it was the spring of hope, it was the winter of despair."]]] t->
                col = t.at "strings"
                res = col.text_length
                res.name . should_equal "text_length([strings])"

                case setup.is_database of
                    False -> res . to_vector . should_equal [6, 0, Nothing, 1, 4, 286] # Grapheme Length
                    True -> res . to_vector . should_equal [6, 0, Nothing, 3, 4, 286]  # Storage Length

        group_builder.specify "text_length should error on non-string columns" <|
            t = table_builder [["numbers", [1, 2, 3]]]
            col = t.at "numbers"
            col.text_length . should_fail_with Invalid_Value_Type

        group_builder.specify "should handle operation text_left and text_right with length 1" <|
            with_mixed_columns_if_supported [["strings", ["a", "foobar", "", Nothing, "café", "It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of light, it was the season of darkness, it was the spring of hope, it was the winter of despair."]]] t->
                col = t.at "strings" . cast (Value_Type.Char size=286 variable_length=True)
                resLeft = col.text_left 1
                resLeft.name . should_equal "text_left([strings], 1)"
                resRight = col.text_right 1
                resRight.name . should_equal "text_right([strings], 1)"
                resLeft . to_vector . should_equal ["a", "f", "", Nothing, "c", "I"]
                resRight . to_vector . should_equal ["a", "r", "", Nothing, "é", "."]

                expected_new_size = case setup.test_selection.char_max_size_after_substring of
                    Char_Max_Size_After_Substring_Behavior.Reset   -> Nothing
                    Char_Max_Size_After_Substring_Behavior.Kept    -> 286
                    Char_Max_Size_After_Substring_Behavior.Reduced -> 1

                Test.with_clue "(Expected behaviour for substring size = "+setup.test_selection.char_max_size_after_substring.to_text+".) " <|
                    resLeft.value_type . should_equal (Value_Type.Char size=expected_new_size variable_length=True)
                    resRight.value_type . should_equal (Value_Type.Char size=expected_new_size variable_length=True)

        group_builder.specify "should handle operation text_left and text_right of grapheme and non-grapheme" <|
            with_mixed_columns_if_supported [["strings", ["a", "foobar", "", Nothing, "👩‍🔬👩‍🔬V👩‍🔬👩‍🔬", "café", "It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of light, it was the season of darkness, it was the spring of hope, it was the winter of despair."]]] t->
                col = t.at "strings"
                resLeft = col.text_left 3
                resLeft.name . should_equal "text_left([strings], 3)"
                resRight = col.text_right 3
                resRight.name . should_equal "text_right([strings], 3)"

                case setup.is_database of
                    False -> resLeft . to_vector . should_equal ["a", "foo", "", Nothing, "👩‍🔬👩‍🔬V", "caf", "It "] # Grapheme Length
                    True -> resLeft . to_vector . should_equal ["a", "foo", "", Nothing, "👩‍🔬", "caf", "It "]  # Storage Length
                case setup.is_database of
                    False -> resRight . to_vector . should_equal ["a", "bar", "", Nothing, "V👩‍🔬👩‍🔬", "afé", "ir."] # Grapheme Length
                    True -> resRight . to_vector . should_equal ["a", "bar", "", Nothing, "👩‍🔬", "afé", "ir."]  # Storage Length

        group_builder.specify "text_left and text_right should error on non-string columns" <|
            t = table_builder [["numbers", [1, 2, 3]]]
            col = t.at "numbers"
            col.text_left 6 . should_fail_with Invalid_Value_Type
            col.text_right 6 . should_fail_with Invalid_Value_Type

        group_builder.specify "text_left and text_right should error on non integer parameters" <|
            t = table_builder [["numbers", [1, 2, 3]]]
            col = t.at "numbers"
            col.text_left 3.14 . should_fail_with Invalid_Value_Type
            col.text_right 3.14 . should_fail_with Invalid_Value_Type
            col.text_left "7" . should_fail_with Invalid_Value_Type
            col.text_left "7" . should_fail_with Invalid_Value_Type

        group_builder.specify "text_left and text_right should return empty on zero argument" <|
            with_mixed_columns_if_supported [["strings", ["a", "foobar", "", Nothing, "👩‍🔬👩‍🔬V👩‍🔬👩‍🔬", "café", "It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of light, it was the season of darkness, it was the spring of hope, it was the winter of despair."]]] t->
                col = t.at "strings"
                resLeft = col.text_left 0
                resLeft.name . should_equal "text_left([strings], 0)"
                resRight = col.text_right 0
                resRight.name . should_equal "text_right([strings], 0)"
                resLeft . to_vector . should_equal ["", "", "", Nothing, "", "", ""]
                resRight . to_vector . should_equal ["", "", "", Nothing, "", "", ""]

        group_builder.specify "text_left and text_right should return empty on negative arguments" <|
            with_mixed_columns_if_supported [["strings", ["a", "foobar", "", Nothing, "👩‍🔬👩‍🔬V👩‍🔬👩‍🔬", "café", "It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of light, it was the season of darkness, it was the spring of hope, it was the winter of despair."]]] t->
                col = t.at "strings"
                resLeft = col.text_left -3
                resLeft.name . should_equal "text_left([strings], -3)"
                resRight = col.text_right -3
                resRight.name . should_equal "text_right([strings], -3)"
                resLeft . to_vector . should_equal ["", "", "", Nothing, "", "", ""]
                resRight . to_vector . should_equal ["", "", "", Nothing, "", "", ""]

        group_builder.specify "should handle operations like is_empty, is_blank, fill_empty" <|
            with_mixed_columns_if_supported [["s", ["", " ", "  ", Nothing, "foo"]], ["letters", ["a", "b", "c", "d", "e"]]] t->
                s = t.at "s"
                s.is_empty . to_vector . should_equal [True, False, False, True, False]
                s.is_blank . to_vector . should_equal [True, False, False, True, False]
                s.fill_empty "<>" . to_vector . should_equal ["<>", " ", "  ", "<>", "foo"]
                s.fill_empty (t.at "letters") . to_vector . should_equal ["a", " ", "  ", "d", "foo"]

        group_builder.specify "should check types" <|
            t4 = table_builder [["str", ['a', 'b']], ["int", [1, 2]]]
            str = t4.at "str"
            int = t4.at "int"
            str.starts_with int . should_fail_with Invalid_Value_Type
            str.ends_with int . should_fail_with Invalid_Value_Type
            str.contains int . should_fail_with Invalid_Value_Type
            str.like int . should_fail_with Invalid_Value_Type
            int.starts_with str . should_fail_with Invalid_Value_Type
            int.ends_with str . should_fail_with Invalid_Value_Type
            int.contains str . should_fail_with Invalid_Value_Type
            int.like str . should_fail_with Invalid_Value_Type
            str.starts_with 42 . should_fail_with Invalid_Value_Type
            str.ends_with 42 . should_fail_with Invalid_Value_Type
            str.contains 42 . should_fail_with Invalid_Value_Type
            str.like 42 . should_fail_with Invalid_Value_Type

            # Mixing text and integers should not be allowed
            (str + int) . should_fail_with Illegal_Argument

            int.fill_empty "<>" . should_fail_with Invalid_Value_Type
            str.fill_empty int . should_fail_with Invalid_Value_Type
            str.fill_empty 42 . should_fail_with Invalid_Value_Type

            int.is_empty . should_fail_with Invalid_Value_Type

        group_builder.specify "should return right types" <|
            t3 = table_builder [["s1", ["foobar", "bar", "baz", "BAB", Nothing]], ["s2", ["foo", "ar", "a", "b", Nothing]]]
            s1 = t3.at "s1"
            s2 = t3.at "s2"
            [Case_Sensitivity.Default, Case_Sensitivity.Sensitive, Case_Sensitivity.Insensitive].each cs->
                s1.starts_with s2 case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.ends_with s2 case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.contains s2 case_sensitivity=cs . value_type . should_equal Value_Type.Boolean

                s1.starts_with "A" case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.ends_with "A" case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.contains "A" case_sensitivity=cs . value_type . should_equal Value_Type.Boolean

            s1.like s2 . value_type . should_equal Value_Type.Boolean
            s1.like "%r%" . value_type . should_equal Value_Type.Boolean

            s1.is_empty . value_type . should_equal Value_Type.Boolean
            s1.is_blank . value_type . should_equal Value_Type.Boolean
            s1.fill_empty "<>" . value_type . should_be_a (Value_Type.Char ...)
            s1.fill_empty s2 . value_type . should_be_a (Value_Type.Char ...)

        group_builder.specify "should support text concatenation with the + operator" <|
            with_mixed_columns_if_supported [["s1", ["foobar", "bar", "baz", "BAB", Nothing]], ["s2", ["foo", "ar", "a", "b", Nothing]]] t3->
                s1 = t3.at "s1"
                s2 = t3.at "s2"
                c1 = s1 + s2
                c1.to_vector . should_equal ["foobarfoo", "barar", "baza", "BABb", Nothing]
                c1.value_type.should_be_a (Value_Type.Char ...)

                c2 = s1 + "_SUF"
                c2.to_vector . should_equal ["foobar_SUF", "bar_SUF", "baz_SUF", "BAB_SUF", Nothing]
                c2.value_type.should_be_a (Value_Type.Char ...)

                c3 = s1 + Nothing
                c3.to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, Nothing]
                c3.value_type.should_be_a (Value_Type.Char ...)

    suite_builder.group prefix+"(Column_Operations_Spec) Min/Max Operations" group_builder->
        data = Min_Max_Data.setup setup.table_builder
        group_builder.specify "should allow one or more args and return the correct type" <|
            c1 = data.a.min 2
            c1.to_vector . should_equal [1, 2, 2]
            setup.expect_integer_type c1

            c2 = data.a.max 2
            c2.to_vector . should_equal [2, 2, 3]
            setup.expect_integer_type c2

            c3 = data.a.min [2.5, 2]
            c3.to_vector . should_equal [1, 2, 2]
            c3.value_type.should_be_a (Value_Type.Float ...)

            c4 = data.a.max [2.5, 2]
            c4.to_vector . should_equal [2.5, 2.5, 3]
            c4.value_type.should_be_a (Value_Type.Float ...)

            c5 = data.a.min data.b
            c5.to_vector . should_equal [1, 2, 3]
            c5.value_type.should_be_a (Value_Type.Float ...)

            c6 = data.a.max data.b
            c6.to_vector . should_equal [4.5, 5.5, 6.5]
            c6.value_type.should_be_a (Value_Type.Float ...)

            c7 = data.a.min [data.a, data.b, 1]
            c7.to_vector . should_equal [1, 1, 1]
            c7.value_type.should_be_a (Value_Type.Float ...)

            c8 = data.a.max [data.a, data.b, 1]
            c8.to_vector . should_equal [4.5, 5.5, 6.5]
            c8.value_type.should_be_a (Value_Type.Float ...)

            c9 = (data.t.at "d").min False
            c9.to_vector . should_equal [False, False, False]
            c9.value_type.should_equal Value_Type.Boolean

            c10 = (data.t.at "d").max False
            c10.to_vector . should_equal [True, False, True]
            c10.value_type.should_equal Value_Type.Boolean

        group_builder.specify "should allow Date/Time columns" pending=pending_datetime <|
            dt_data = Min_Max_Datetime_Data.setup setup.table_builder
            c1 = dt_data.table.at "dates1" . min (Date.new 2021 1 2)
            c1.to_vector . should_equal [Date.new 2021 1 1, Date.new 2021 1 2, Date.new 2021 1 2]
            c1.value_type.should_equal Value_Type.Date

            c2 = dt_data.table.at "dates1" . min (dt_data.table.at "dates2")
            c2.to_vector . should_equal [Date.new 2021 1 1, Date.new 2021 1 2, Date.new 2000 12 1]

            c3 = dt_data.table.at "dates1" . max (Date.new 2021 1 2)
            c3.to_vector . should_equal [Date.new 2021 1 2, Date.new 2021 1 2, Date.new 2021 1 3]

            c4 = dt_data.table.at "dates1" . max (dt_data.table.at "dates2")
            c4.to_vector . should_equal [Date.new 2021 1 1, Date.new 2021 1 3, Date.new 2021 1 3]

            c5 = dt_data.table.at "times1" . min (Time_Of_Day.new 2 2 2)
            c5.to_vector . should_equal [Time_Of_Day.new 1 2 3 4, Time_Of_Day.new 2 2 2, Time_Of_Day.new 2 2 2]
            c5.value_type.should_equal Value_Type.Time

            c6 = dt_data.table.at "times1" . min (dt_data.table.at "times2")
            c6.to_vector . should_equal [Time_Of_Day.new 1 2 3 4, Time_Of_Day.new 1 1 1 1, Time_Of_Day.new 5 6 7 8]

            c7 = dt_data.table.at "times1" . max (Time_Of_Day.new 2 2 2)
            c7.to_vector . should_equal [Time_Of_Day.new 2 2 2, Time_Of_Day.new 3 4 5 6, Time_Of_Day.new 5 6 7 8]

            c8 = dt_data.table.at "times1" . max (dt_data.table.at "times2")
            c8.to_vector . should_equal [Time_Of_Day.new 1 2 3 4, Time_Of_Day.new 3 4 5 6, Time_Of_Day.new 10 10 10 10]

            c9 = dt_data.table.at "date_times1" . min (Date_Time.new 2021 1 2 2 2 2)
            c9.to_vector . should_equal_tz_agnostic [Date_Time.new 2021 1 1 1 2 3 4, Date_Time.new 2021 1 2 2 2 2, Date_Time.new 2021 1 2 2 2 2]

            c10 = dt_data.table.at "date_times1" . min (dt_data.table.at "date_times2")
            c10.to_vector . should_equal_tz_agnostic [Date_Time.new 2021 1 1 1 2 3 4, Date_Time.new 2021 1 2 3 4 5 6, Date_Time.new 2000 12 1 10 10 10 10]

            c11 = dt_data.table.at "date_times1" . max (Date_Time.new 2021 1 2 2 2 2)
            c11.to_vector . should_equal_tz_agnostic [Date_Time.new 2021 1 2 2 2 2, Date_Time.new 2021 1 2 3 4 5 6, Date_Time.new 2021 1 3 5 6 7 8]

            c12 = dt_data.table.at "date_times1" . max (dt_data.table.at "date_times2")
            c12.to_vector . should_equal_tz_agnostic [Date_Time.new 2021 1 1 1 2 3 4, Date_Time.new 2021 1 3 1 2 3 4, Date_Time.new 2021 1 3 5 6 7 8]

        group_builder.specify "should check types" <|
            [(.min), (.max)].each op->
                op data.a data.c . should_fail_with Invalid_Value_Type
                op data.a [1, 2, data.c] . should_fail_with Invalid_Value_Type
                op data.a [1, Nothing, data.c, Nothing] . should_fail_with Invalid_Value_Type
                op data.c 1 . should_fail_with Invalid_Value_Type
                op data.a True . should_fail_with Invalid_Value_Type

    do_replace column (term : Text | Regex | Column | DB_Column) new_text case_sensitivity=Case_Sensitivity.Default only_first=False expected =
        case setup.is_database of
            True ->
                input_type = Meta.type_of term
                params = Replace_Params.Value input_type case_sensitivity only_first
                supported_replace_params = setup.test_selection.supported_replace_params
                supported_replace_params . should_be_a Hashset
                are_params_supported = supported_replace_params.contains params
                case are_params_supported of
                    True -> column.text_replace term new_text case_sensitivity only_first . to_vector . should_equal expected
                    False -> column.text_replace term new_text case_sensitivity only_first . should_fail_with Unsupported_Database_Operation
            False ->
                result = column.text_replace term new_text case_sensitivity only_first
                result.value_type . should_equal Value_Type.Char
                result . to_vector . should_equal expected

    literal_data = Literal_Data.setup setup.table_builder
    suite_builder.group prefix+"(Column_Operations_Spec) replace: literal text pattern and replacement" group_builder->
        group_builder.specify "case_sensitivity=sensitive/default use_regex=false only_first=false"
            do_replace literal_data.col0 'hello' 'bye' expected=['bye Hello', 'bye bye', 'HELLO HELLO']
            do_replace literal_data.col0 'hello' 'bye' case_sensitivity=Case_Sensitivity.Default expected=['bye Hello', 'bye bye', 'HELLO HELLO']
            do_replace literal_data.col0 'hello' 'bye' case_sensitivity=Case_Sensitivity.Sensitive expected=['bye Hello', 'bye bye', 'HELLO HELLO']
            do_replace literal_data.col1 'a[bcd]' 'hey' expected=['hey A[bCd] hey', 'abac ad Ab aCAd']

        group_builder.specify "case_sensitivity=sensitive/default use_regex=false only_first=true"
            do_replace literal_data.col0 'hello' 'bye' only_first=True expected=['bye Hello', 'bye hello', 'HELLO HELLO']
            do_replace literal_data.col1 'a[bcd]' 'hey' only_first=True expected=['hey A[bCd] a[bcd]', 'abac ad Ab aCAd']

        group_builder.specify "case_sensitivity=insensitive use_regex=false only_first=false"
            do_replace literal_data.col0 'hello' 'bye' case_sensitivity=Case_Sensitivity.Insensitive expected=['bye bye', 'bye bye', 'bye bye']
            do_replace literal_data.col1 'a[bcd]' 'hey' case_sensitivity=Case_Sensitivity.Insensitive expected=['hey hey hey', 'abac ad Ab aCAd']

        group_builder.specify "case_sensitivity=insensitive use_regex=false only_first=true"
            do_replace literal_data.col0 'hello' 'bye' case_sensitivity=Case_Sensitivity.Insensitive only_first=True expected=['bye Hello', 'bye hello', 'bye HELLO']
            do_replace literal_data.col1 'a[bcd]' 'hey' case_sensitivity=Case_Sensitivity.Insensitive only_first=True expected=['hey A[bCd] a[bcd]', 'abac ad Ab aCAd']

    suite_builder.group prefix+"(Column_Operations_Spec) replace: literal regex pattern and replacement" group_builder->
        group_builder.specify "case_sensitivity=sensitive/default use_regex=True only_first=false"
            do_replace literal_data.col1 'a[bcd]'.to_regex 'hey' expected=['a[bcd] A[bCd] a[bcd]', 'heyhey hey Ab aCAd']

        group_builder.specify "case_sensitivity=sensitive/default use_regex=True only_first=true"
            do_replace literal_data.col1 'a[bcd]'.to_regex 'hey' only_first=True expected=['a[bcd] A[bCd] a[bcd]', 'heyac ad Ab aCAd']

        group_builder.specify "case_sensitivity=insensitive use_regex=True only_first=false"
            do_replace literal_data.col1 'a[bcd]'.to_regex 'hey' case_sensitivity=Case_Sensitivity.Insensitive expected=['a[bcd] A[bCd] a[bcd]', 'heyhey hey hey heyhey']

        group_builder.specify "case_sensitivity=insensitive use_regex=True only_first=true"
            do_replace literal_data.col1 'a[bcd]'.to_regex 'hey' case_sensitivity=Case_Sensitivity.Insensitive only_first=True expected=['a[bcd] A[bCd] a[bcd]', 'heyac ad Ab aCAd']

        group_builder.specify "can properly escape complex regexes" <|
            regex = "^([^\(]+)|(?<foo>\w\d[a-z])+$"
            col = table_builder [["x", [regex]]] . at "x"
            do_replace col regex "asdf" ["asdf"]
    
    suite_builder.group prefix+"(Column_Operations_Spec) replace: Named_Pattern and replacement" group_builder->
        group_builder.specify "can use Named_Patterns" <|
            do_replace literal_data.col1 Named_Pattern.Symbols 'hey' expected=['aheybcdhey AheybCdhey aheybcdhey', 'abac ad Ab aCAd']

    suite_builder.group prefix+"(Column_Operations_Spec) replace: pattern and replacement columns" group_builder->
        data = Replace_Data.setup setup.table_builder
        group_builder.specify "case_sensitivity=sensitive/default use_regex=false only_first=false"
            do_replace data.col data.patterns data.replacements expected=['bye Hello', 'bye bye', 'HELLO HELLO', 'hey A[bCd] hey', 'abac ad Ab aCAd']
            do_replace data.col data.patterns data.replacements case_sensitivity=Case_Sensitivity.Default expected=['bye Hello', 'bye bye', 'HELLO HELLO', 'hey A[bCd] hey', 'abac ad Ab aCAd']
            do_replace data.col data.patterns data.replacements case_sensitivity=Case_Sensitivity.Sensitive expected=['bye Hello', 'bye bye', 'HELLO HELLO', 'hey A[bCd] hey', 'abac ad Ab aCAd']

        group_builder.specify "case_sensitivity=sensitive/default use_regex=false only_first=true"
            do_replace data.col data.patterns data.replacements only_first=True expected=['bye Hello', 'bye hello', 'HELLO HELLO', 'hey A[bCd] a[bcd]', 'abac ad Ab aCAd']

        group_builder.specify "case_sensitivity=insensitive use_regex=false only_first=false"
            do_replace data.col data.patterns data.replacements case_sensitivity=Case_Sensitivity.Insensitive expected=['bye bye', 'bye bye', 'bye bye', 'hey hey hey', 'abac ad Ab aCAd']

        group_builder.specify "case_sensitivity=insensitive use_regex=false only_first=true"
            do_replace data.col data.patterns data.replacements case_sensitivity=Case_Sensitivity.Insensitive only_first=True expected=['bye Hello', 'bye hello', 'bye HELLO', 'hey A[bCd] a[bcd]', 'abac ad Ab aCAd']

    suite_builder.group prefix+"(Column_Operations_Spec) replace: empty table and nothings" group_builder->
        table_builder = build_sorted_table table_builder=setup.light_table_builder
        group_builder.specify "should work on empty tables" <|
            col = table_builder [["x", ['hello Hello']]] . filter "x" (Filter_Condition.Is_Nothing) . at "x"
            do_replace col 'hello' 'bye' expected=[]

        group_builder.specify "should work on Nothing text column" <|
            col = table_builder [["x", ['hello Hello', Nothing]]] . filter "x" (Filter_Condition.Is_Nothing) . at "x"
            do_replace col 'hello' 'bye' expected=[Nothing]

    if setup.is_database then suite_builder.group prefix+"(Column_Operations_Spec) replace: DB specific edge-cases" group_builder->
        table_builder = build_sorted_table table_builder=setup.light_table_builder
        group_builder.specify "should not allow Case_Sensitivity.Insensitive with a non-default locale" <|
            col = table_builder [["A", ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]]] . at 'A'
            locale = Locale.new "en" "GB" "UTF-8"
            col.text_replace 'asdf' 'zxcv' case_sensitivity=(Case_Sensitivity.Insensitive locale) . should_fail_with Illegal_Argument

        group_builder.specify "column name" <|
            table = table_builder [["x", ['hello Hello', 'hello hello', 'HELLO HELLO', 'a[bcd] A[bCd] a[bcd]', 'abac ad Ab aCAd']], ["patterns", ['hello', 'hello', 'hello', 'a[bcd]', 'a[bcd]']], ["replacements", ['bye', 'bye', 'bye', 'hey', 'hey']]]
            col = table.at "x"
            patterns = table.at "patterns"
            replacements = table.at "replacements"

            supported_replace_params = setup.test_selection.supported_replace_params
            if supported_replace_params.contains (Replace_Params.Value Text Case_Sensitivity.Default False) then
                col.text_replace 'hello' 'bye' . name . should_equal 'replace([x], \'hello\', \'bye\')'
            if supported_replace_params.contains (Replace_Params.Value Regex Case_Sensitivity.Default False) then
                col.text_replace 'a[bcd]'.to_regex 'hey' . name . should_equal 'replace([x], \'a[bcd]\', \'hey\')'
            if supported_replace_params.contains (Replace_Params.Value DB_Column Case_Sensitivity.Default False) then
                col.text_replace patterns replacements . name . should_equal 'replace([x], [patterns], [replacements])'

    suite_builder.group prefix+"(Column_Operations_Spec) Column Operations - Text Replace (in-memory only)" group_builder->

        if setup.is_database.not then
            data = Text_Replace_Data.setup setup.table_builder
            group_builder.specify "should allow simple replacing" <|
                data.a.text_replace "a" "#" . to_vector . should_equal ["Alph#", "Br#vo", "Ch#rlie", "Delt#", "Echo", "Foxtrot"]
                data.a.text_replace "o" "#" . to_vector . should_equal ["Alpha", "Brav#", "Charlie", "Delta", "Ech#", "F#xtr#t"]
                data.a.text_replace data.b "#" . to_vector . should_equal ["#lpha", "Bravo", "Ch#rlie", "Delta", "Ech#", "Foxtrot"]
                data.a.text_replace "o" "#" only_first=True . to_vector . should_equal ["Alpha", "Brav#", "Charlie", "Delta", "Ech#", "F#xtrot"]
                data.a.text_replace "a" "#" Case_Sensitivity.Insensitive . to_vector . should_equal ["#lph#", "Br#vo", "Ch#rlie", "Delt#", "Echo", "Foxtrot"]
                data.a.text_replace data.b "#" Case_Sensitivity.Insensitive . to_vector . should_equal ["#lph#", "Brav#", "Ch#rlie", "D#lta", "Ech#", "F#xtr#t"]
                data.a.text_replace data.b "#" Case_Sensitivity.Insensitive only_first=True . to_vector . should_equal ["#lpha", "Brav#", "Ch#rlie", "D#lta", "Ech#", "F#xtrot"]

            group_builder.specify "should allow regex based replacing" <|
                data.a.text_replace "[aeiou]".to_regex "#" . to_vector . should_equal ["Alph#", "Br#v#", "Ch#rl##", "D#lt#", "Ech#", "F#xtr#t"]
                data.a.text_replace "[aeiou]".to_regex "#" . to_vector . should_equal ["Alph#", "Br#v#", "Ch#rl##", "D#lt#", "Ech#", "F#xtr#t"]
                data.a.text_replace "([aeiou])(.*?)[aeiou]".to_regex "$1$2$1" . to_vector . should_equal ["Alpha", "Brava", "Charlae", "Delte", "Echo", "Foxtrot"]

            group_builder.specify "should handle unicode" <|
                table = table_builder [["x", ["śćxx", "ąąasdfąą", "aﬃb"]], ["patterns", ["ć", "ąą", "ﬃ"]], ["replacements", ["abc", "def", "ghi"]]]
                col = table.at "x"
                patterns = table.at "patterns"
                replacements = table.at "replacements"

                col.text_replace patterns replacements . to_vector . should_equal ["śabcxx", "defasdfdef", "aghib"]

            group_builder.specify "should take pattern and replacement string columns" <|
                t = table_builder [["x", ["hello", "what", "yes"]], ["patterns", ["ell", "wh", "es"]], ["replacements", ["xyz", "qwer", "asdf"]]]
                col = t.at "x"
                patterns = t.at "patterns"
                replacements = t.at "replacements"

                col.text_replace patterns replacements . to_vector . should_equal ["hxyzo", "qwerat", "yasdf"]

            group_builder.specify "should only allow replace on Text columns" <|
                data.c.text_replace "a" "#" . should_fail_with Invalid_Value_Type
                Test.expect_panic Type_Error (data.a.text_replace 1 "#")
                data.a.text_replace data.c "#" . should_fail_with Invalid_Value_Type
                data.a.text_replace "a" 1 . should_fail_with Invalid_Value_Type
                data.a.text_replace "a" data.c . should_fail_with Invalid_Value_Type

            group_builder.specify "should not replace if Empty term" <|
                data.a.text_replace '' "#" . to_vector . should_equal ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]
                data.a.text_replace data.d "#" . to_vector . should_equal ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]

            group_builder.specify "should infer correct return type" <|
                c = table_builder [["texts", ["foo", "bar"]]] . at "texts"

                c1 = c.text_replace "a" "---"
                c1.to_vector . should_equal ["foo", "b---r"]
                vt1 = c1.value_type
                Test.with_clue "c1.value_type="+vt1.to_display_text+": " <|
                    vt1.should_be_a (Value_Type.Char ...)
                    vt1.variable_length.should_be_true

            group_builder.specify "should infer correct return type (2)" pending=(if setup.test_selection.fixed_length_text_columns.not then "Fixed-length Char columns are not supported by this backend.") <|
                c = table_builder [["texts", ["foo", "bar"]]] . at "texts"
                c2 = c.cast (Value_Type.Char size=2 variable_length=False)
                c3 = c2.text_replace "a" "---"

                c3.to_vector . should_equal ["fo", "b---"]
                vt3 = c3.value_type
                Test.with_clue "c3.value_type="+vt3.to_display_text+": " <|
                    vt3.should_be_a (Value_Type.Char ...)
                    vt3.variable_length.should_be_true

    suite_builder.group prefix+"(Column_Operations_Spec) Column Operations - Text Trim" group_builder->
        data = Trim_Data.setup setup.table_builder
        group_builder.specify "should trim whitespace by default" <|
            with_mixed_columns_if_supported [["A", [" A ", ' \t\n\rA\r\n\t ', "xxxAxx"]]] t->
                a = t.at "A"
                a.trim . to_vector . should_equal ["A", "A", "xxxAxx"]
                a.trim ..Left . to_vector . should_equal ["A ", 'A\r\n\t ', "xxxAxx"]
                a.trim ..Right . to_vector . should_equal [" A", ' \t\n\rA', "xxxAxx"]

       group_builder.specify "should trim custom characters" <|
            data.a.trim what='x' . to_vector . should_equal [" A ", ' \t\n\rA\r\n\t ', "A"]
            data.a.trim what='x' ..Left . to_vector . should_equal [" A ", ' \t\n\rA\r\n\t ', "Axx"]
            data.a.trim what='x' ..Right . to_vector . should_equal [" A ", ' \t\n\rA\r\n\t ', "xxxA"]
            data.a.trim what=' ' . to_vector . should_equal ["A", '\t\n\rA\r\n\t', "xxxAxx"]
            data.a.trim what=' \t' . to_vector . should_equal ["A", '\n\rA\r\n', "xxxAxx"]
            data.a.trim what=' \r' . to_vector . should_equal ["A", '\t\n\rA\r\n\t', "xxxAxx"]
            data.a.trim what=data.b . to_vector . should_equal ["A", '\n\rA\r\n', "A"]

        group_builder.specify "should only allow trim on Text columns" <|
            data.c.trim what="a" . should_fail_with Invalid_Value_Type
            data.a.trim what=1 . should_fail_with Invalid_Value_Type
            data.a.trim what=data.c . should_fail_with Invalid_Value_Type

    suite_builder.group prefix+"(Column_Operations_Spec) Other Column Operations" group_builder->
        table_builder = build_sorted_table table_builder=setup.light_table_builder
        group_builder.specify "is_in" <|
            t = table_builder [["X", [1, 2, 3, 4]], ["Y", [4, 3, 100, 200]]]
            x = t.at "X"
            y = t.at "Y"

            c1 = x.is_in  [2, 100, 5]
            c1.to_vector . should_equal [False, True, False, False]
            c1.value_type.should_equal Value_Type.Boolean

            c2 = x.is_in y
            c2.to_vector . should_equal [False, False, True, True]
            c2.value_type.should_equal Value_Type.Boolean

    suite_builder.group prefix+"(Column_Operations_Spec) Colum Operations - Names" group_builder->
        data = Names_Data.setup setup.table_builder
        group_builder.specify "arithmetic" <|
            ((data.t.at "a") + 42) . name . should_equal "[a] + 42"
            ((data.t.at "a") - (data.t.at "c")) . name . should_equal "[a] - [c]"
            ((data.t.at "a") * (data.t.at "c")) . name . should_equal "[a] * [c]"
            ((data.t.at "a") / (data.t.at "c")) . name . should_equal "[a] / [c]"
            ((data.t.at "a") % (data.t.at "c")) . name . should_equal "[a] % [c]"
            ((data.t.at "a") ^ (data.t.at "c")) . name . should_equal "[a] ^ [c]"
            ((data.t.at "b") + 'xyz') . name . should_equal "[b] + 'xyz'"
            ((data.t.at "b") + '\0') . name . should_equal "[b] + '\0'"

        group_builder.specify "comparison" <|
            ((data.t.at "b") == '\0\0') . name . should_equal "[b] == '\0\0'"
            ((data.t.at "b") != '\0\0') . name . should_equal "[b] != '\0\0'"
            ((data.t.at "a") < 0) . name . should_equal "[a] < 0"
            ((data.t.at "a") <= 0) . name . should_equal "[a] <= 0"
            ((data.t.at "a") > 0) . name . should_equal "[a] > 0"
            ((data.t.at "b") >= 'X') . name . should_equal "[b] >= 'X'"
            ((data.t.at "a").between (data.t.at "c") 42) . name . should_equal "[a] between [c] and 42"

        group_builder.specify "logical" <|
            ((data.t.at "d") || False) . name . should_equal "[d] || False"
            ((data.t.at "d") && True) . name . should_equal "[d] && True"
            ((data.t.at "d").not) . name . should_equal "not [d]"
            ((data.t.at "d").iif 10 20) . name . should_equal "if [d] then 10 else 20"

        group_builder.specify "text" <|
            data.t.at "b" . equals_ignore_case "abc" . name . should_equal "equals_ignore_case([b], 'abc')"
            data.t.at "b" . starts_with "abc" . name . should_equal "starts_with([b], 'abc')"
            data.t.at "b" . contains "abc" . name . should_equal "contains([b], 'abc')"
            data.t.at "b" . like "%abc%" . name . should_equal "[b] like '%abc%'"
            data.t.at "b" . ends_with "abc" . name . should_equal "ends_with([b], 'abc')"
            data.t.at "b" . is_empty . name . should_equal "[b] is empty"
            data.t.at "b" . fill_empty "<empty>" . name . should_equal "b"

        group_builder.specify "nulls" <|
            data.t.at "a" . coalesce [Nothing, 42] . name . should_equal "coalesce([a], Nothing, 42)"
            data.t.at "a" . is_nothing . name . should_equal "[a] is Nothing"
            data.t.at "a" . is_present . name . should_equal "is_present([a])"
            data.t.at "a" . is_blank . name . should_equal "is_blank([a])"
            data.t.at "a" . fill_nothing 100 . name . should_equal "a"

        group_builder.specify "misc"
            data.t.at "a" . min [1, 2] . name . should_equal "min([a], 1, 2)"
            data.t.at "a" . max 33 . name . should_equal "max([a], 33)"
            data.t.at "a" . is_in [1, 2, 3] . name . should_equal "[a] in [1, 2, 3]"

        group_builder.specify "composed operations" <|
            # These look a bit weird, but they are consistent with the column name escaping scheme.
            ((data.t.at "a" + 42) * (data.t.at "c")) . name . should_equal "[[a] + 42] * [c]"
            ((data.t.at "a" + 42) * (data.t.at "c") - 33) . name . should_equal "[[[a] + 42] * [c]] - 33"

        group_builder.specify "sort" <|
            data.t.at "a" . sort . name . should_equal "a"

        if setup.is_database.not then
            group_builder.specify "parse" <|
                t2 = table_builder [["X", ["1", "2", "3"]]]
                t2.at "X" . parse . name . should_equal "X"

            group_builder.specify "map and zip" <|
                data.t.at "a" . map (x -> x + 1) . name . should_equal "a"
                data.t.at "a" . zip (data.t.at "b") [_, _] . name . should_equal "[a] x [b]"

    suite_builder.group prefix+"(Column_Operations_Spec) Column.rename" group_builder->
        group_builder.specify "should not allow illegal names" <|
            t = table_builder [["a", [1, 2, 3]]]
            c = t.at "a"

            c.rename Nothing . should_fail_with Invalid_Column_Names
            c.rename '' . should_fail_with Invalid_Column_Names
            c.rename 'a\0b' . should_fail_with Invalid_Column_Names
            c.rename '\0' . should_fail_with Invalid_Column_Names

    suite_builder.group prefix+"(Column_Operations_Spec) Column.const" group_builder->
        group_builder.specify "Should allow the creation of constant columns" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            t.at "x" . const True . to_vector . should_equal [True, True, True]
            t.at "x" . const 12 . to_vector . should_equal [12, 12, 12]
            t.at "x" . const 12.3 . to_vector . should_equal [12.3, 12.3, 12.3]
            t.at "x" . const "asdf" . to_vector . should_equal ["asdf", "asdf", "asdf"]

        group_builder.specify "Should create the correct column name" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            t.at "x" . const 12 . name . should_equal "12"

        group_builder.specify "Should not allow the creation of a constant column of columns" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            t.at "x" . const (t.at "x") . should_fail_with Illegal_Argument

    if setup.is_database then
        suite_builder.group prefix+"(Column_Operations_Spec) Column.let" group_builder->
            connection_data = Connection_Data.setup create_connection_fn

            group_builder.teardown <|
                connection_data.teardown

            if connection_data.connection.dialect.flagged ..Supports_Nested_With_Clause then
                group_builder.specify "Should allow the use of let-style CTEs" <|
                    t = table_builder [["X", [1, 2, 3, 4]], ["Y", [4, 3, 100, 200]], ["Z", [12.1, 23.4, -4.5, 44.33]]]
                    x = t.at "X"
                    y = t.at "Y"
                    z = t.at "Z"
                    a = ((x - 2.3) * (y + 1)) + z
                    b = (x - 2.3).let "xx" xx-> (xx * (y + 1)) + z
                    c = (x - 2.3).let "xx" xx-> (y + 1).let "yy" yy-> (xx * yy) + z
                    d = ((x - 2.3) * (y + 1)).let "xxyy" xxyy-> xxyy + z

                    r = t . set a "a" . set b "b" . set c "c" . set d "d" . order_by ["X"] . read
                    r.at "a" . to_vector . should_equal [5.6000000000000005, 22.2, 66.20000000000002, 386.03000000000003]
                    r.at "a" . to_vector . should_equal (r.at "b" . to_vector)
                    r.at "a" . to_vector . should_equal (r.at "c" . to_vector)
                    r.at "a" . to_vector . should_equal (r.at "d" . to_vector)

                    a.to_table.to_sql . prepare . at 0 . should_not_contain "WITH"
                    b.to_table.to_sql . prepare . at 0 . should_contain 'xx_0'
                    c.to_table.to_sql . prepare . at 0 . should_contain 'xx_0'
                    c.to_table.to_sql . prepare . at 0 . should_contain 'yy_1'
                    d.to_table.to_sql . prepare . at 0 . should_contain 'xxyy_0'

    suite_builder.group prefix+"(Column_Operations_Spec) Table.make_constant_column" group_builder->
        group_builder.specify "Should allow the creation of constant columns" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            c1 = t.make_constant_column True
            c1.to_vector . should_equal [True, True, True]
            c1.value_type.should_equal Value_Type.Boolean

            c2 = t.make_constant_column 12
            c2.to_vector . should_equal [12, 12, 12]
            setup.expect_integer_type c2

            c3 = t.make_constant_column 12.3
            c3.to_vector . should_equal [12.3, 12.3, 12.3]
            c3.value_type.should_be_a (Value_Type.Float ...)

            c4 = t.make_constant_column "asdf"
            c4.to_vector . should_equal ["asdf", "asdf", "asdf"]
            c4.value_type.should_be_a (Value_Type.Char ...)

        if setup.test_selection.date_time then group_builder.specify "Should allow the creation of constant date/time columns" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            d = Date.new 2024 07 05
            c1 = t.make_constant_column d
            c1.to_vector . should_equal [d, d, d]
            c1.value_type.should_equal Value_Type.Date

            dt = Date_Time.new 2024 07 05 12 30 45
            c2 = t.make_constant_column dt
            c2.value_type.should_be_a (Value_Type.Date_Time ...)

            time = Time_Of_Day.new 12 30 45
            c3 = t.make_constant_column time
            c3.to_vector . should_equal [time, time, time]
            c3.value_type.should_equal Value_Type.Time

            # The types should be preserved after an 'identity' operation:
            c1_prime = (c1 == c1).iif c1 c1
            c1_prime.value_type.should_equal Value_Type.Date

            c2_prime = (c2 == c2).iif c2 c2
            c2_prime.value_type.should_be_a (Value_Type.Date_Time ...)

            c3_prime = (c3 == c3).iif c3 c3
            c3_prime.value_type.should_equal Value_Type.Time

        group_builder.specify "Should allow the creation of constant columns on a table with no rows" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            empty = t.take 0
            constant = empty.make_constant_column 42
            empty2 = empty.set constant
            empty2.column_names.should_equal ['x', '42']

        group_builder.specify "Should create a column of the correct type on a table with no rows" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            empty = t.take 0

            check value expected_type =
                c = empty.make_constant_column value
                c.value_type.should_be_a expected_type
                (empty.set c).at c.name . value_type . should_be_a expected_type

            check False Value_Type.Boolean
            check "42" (Value_Type.Char ...)
            check "foo" (Value_Type.Char ...)
            check 1.1 (Value_Type.Float ...)

            c = empty.make_constant_column 42
            setup.expect_integer_type c

        nulls_db_pending = if setup.is_database then "Empty NULL columns are unsupported in the database backends"
        group_builder.specify "Should create a column of the correct type on a table with no rows" pending=nulls_db_pending <|
            t = table_builder [["x", ["1", "2", "3"]]]
            empty = t.take 0
            c = empty.make_constant_column Nothing
            c.value_type . should_equal Value_Type.Mixed
            (empty.set c).at c.name . value_type . should_equal Value_Type.Mixed

    decimal_db_pending = if setup.is_database then "Decimals are currently not implemented for the Database backend."
    suite_builder.group prefix+"(Column_Operations_Spec) Decimal" pending=decimal_db_pending group_builder->
        table_builder = setup.light_table_builder
        group_builder.specify "can store and retrieve values" <|
            t = table_builder [["x", [Decimal.new "23257245345.345345345"]]]
            t.at "x" . at 0 . should_be_a Decimal
            t.at "x" . get 0 . should_be_a Decimal

        group_builder.specify "arithmetic (decimal column and decimal column)" <|
            t = table_builder [["x", [Decimal.new "23257245345.345345345"]], ["y", [Decimal.new "123e50"]], ["z", [Decimal.new "125e50"]], ["w", [Decimal.new 7513]], ["v", [Decimal.new "3.7"]]]
            (t.at "x" + t.at "y").to_vector . should_equal [Decimal.new "12300000000000000000000000000000000000000023257245345.345345345"]
            (t.at "x" - t.at "y").to_vector . should_equal [Decimal.new "-12299999999999999999999999999999999999999976742754654.654654655"]
            (t.at "x" * t.at "y").to_vector . should_equal [Decimal.new "2.860641177477477477435E+62"]
            (t.at "x" / t.at "z").to_vector . should_equal [Decimal.new "1.8605796276276276276E-42"]
            (t.at "x" % t.at "w").to_vector . should_equal [Decimal.new "2545.345345345"]
            (t.at "x" ^ t.at "v").to_vector . should_equal [Decimal.new "2.27125352907938E38" . to_float]

        group_builder.specify "arithmetic (decimal column and non-decimal column)" <|
            t = table_builder [["x", [Decimal.new "101.25"]], ["y", [30]], ["z", [40.5]], ["w", [2]], ["wf", [2.0]], ["wf2", [2.1]]]

            (t.at "x" + t.at "y").to_vector . should_equal [Decimal.new "131.25"]
            (t.at "x" - t.at "y").to_vector . should_equal [Decimal.new "71.25"]
            (t.at "x" * t.at "y").to_vector . should_equal [Decimal.new "3037.5"]
            (t.at "x" / t.at "y").to_vector . should_equal [Decimal.new "3.375"]
            (t.at "x" % t.at "y").to_vector . should_equal [Decimal.new "11.25"]

            (t.at "x" + t.at "z").to_vector . should_equal [Decimal.new "141.75"]
            (t.at "x" - t.at "z").to_vector . should_equal [Decimal.new "60.75"]
            (t.at "x" * t.at "z").to_vector . should_equal [Decimal.new "4100.625"]
            (t.at "x" / t.at "z").to_vector . should_equal [Decimal.new "2.5"]
            (t.at "x" % t.at "z").to_vector . should_equal [Decimal.new "20.25"]

            (t.at "x" ^ t.at "w").to_vector . should_equal [Decimal.new "10251.5625"]
            (t.at "x" ^ t.at "wf").to_vector . should_equal [Decimal.new "10251.5625"]
            (t.at "x" ^ t.at "wf2").to_vector . should_equal [16267.827812994828]

        group_builder.specify "arithmetic (column and scalar)" <|
            t = table_builder [["x", [Decimal.new "23257245345.345345345"]], ["y", [Decimal.new "944548245.68648775"]]]

            (t.at "x" + 10) . to_vector . should_equal [Decimal.new "23257245355.345345345"]
            (t.at "x" - 10) . to_vector . should_equal [Decimal.new "23257245335.345345345"]
            (t.at "x" * 10) . to_vector . should_equal [Decimal.new "232572453453.45345345"]
            (t.at "x" / 10) . to_vector . should_equal [Decimal.new "2325724534.5345345345"]
            (t.at "x" ^ 2) . to_vector . should_equal [Decimal.new "5.408994610535877E20" . to_float]

            (t.at "x" + 10.1) . to_vector . should_equal [Decimal.new "23257245355.445345345"]
            (t.at "x" - 10.1) . to_vector . should_equal [Decimal.new "23257245335.245345345"]
            (t.at "x" * 10.1) . to_vector . should_equal [Decimal.new "234898177987.9879879845"]
            (t.at "y" / 16.5) . to_vector . should_equal [Decimal.new "57245348.2234235"]
            (t.at "x" ^ 2.0) . to_vector . should_equal [Decimal.new "5.408994610535877E20" . to_float]

            (t.at "x" + 2^80) . to_vector . should_equal [Decimal.new "1208925819614652431951521.345345345"]
            (t.at "x" - 2^80) . to_vector . should_equal [Decimal.new "-1208925819614605917460830.654654655"]
            (t.at "x" * 2^80) . to_vector . should_equal [Decimal.new "28116284391100140971590625398136689.624350720"]
            (t.at "y" / 2^80) . to_vector . should_equal [Decimal.new "0.0000000000000007813119964528366172913694049826337229003314632791443727910518646240234375"]

            (t.at "x" + (Decimal.new "10.1")) . to_vector . should_equal [Decimal.new "23257245355.445345345"]
            (t.at "x" - (Decimal.new "10.1")) . to_vector . should_equal [Decimal.new "23257245335.245345345"]
            (t.at "x" * (Decimal.new "10.1")) . to_vector . should_equal [Decimal.new "234898177987.9879879845"]
            (t.at "y" / (Decimal.new "16.5")) . to_vector . should_equal [Decimal.new "57245348.2234235"]
            (t.at "x" ^ (Decimal.new "2.0")) . to_vector . should_equal [Decimal.new "5.408994610535877E20" . to_float]

        group_builder.specify "arithmetic errors" <|
            t = table_builder [["x", [Decimal.new "1"]], ["y", [Decimal.new "3"]], ["z", [Decimal.new "0"]]]

            r0 = t.at "x" / t.at "y"
            r0 . to_vector . should_equal [Nothing]
            nt_error = Arithmetic_Error.Error "Non-terminating decimal expansion; no exact representable decimal result. Please use `.divide` with an explicit `Math_Context` to limit the numeric precision. (at rows [0])."
            Problems.expect_only_warning nt_error r0

            r1 = t.at "x" / t.at "z"
            r1 . to_vector . should_equal [Nothing]
            Problems.expect_only_warning Arithmetic_Error r1

            r2 = t.at "x" % t.at "z"
            r2 . to_vector . should_equal [Nothing]
            Problems.expect_only_warning Arithmetic_Error r2

# A dummy value used to force the in-memory backend to trigger a infer a mixed type for the given column.
type Mixed_Type_Object

all_combinations variables =
    Vector.build builder->
        go current_choices =
            i = current_choices.length
            if i == variables.length then builder.append current_choices else
                choices = variables.at i
                choices.each x->
                    go (current_choices + [x])
        go []

drop_table connection table =
    case table of
        _ : DB_Table ->
            connection.drop_table table.name
        _ -> Nothing
